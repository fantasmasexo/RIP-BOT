try {
  // Seu c√≥digo aqui
  const { default: makeWASocket, makeCacheableSignalKeyStore, downloadContentFromMessage, useMultiFileAuthState, makeInMemoryStore, DisconnectReason, WAGroupMetadata, relayWAMessage, MediaPathMap, mentionedJid, processTime, MediaType, Browser, MessageType, Presence, Mimetype, Browsers, delay, fetchLatestBaileysVersion, MessageRetryMap, extractGroupMetadata, generateWAMessageFromContent, proto } = require('@whiskeysockets/baileys');
  ///////////////////////////////////////////////
  //PEDEM DE MUDELE
  ///////////////////////////////////////////////
  const mimetype = require("mime-types")
  const fs = require('fs');
  const P = require('pino');
  //const { node-webpmux } = require("node-webpmux")
  const ytts = require("yt-search");
  const ytttts = require("yt-search");
  const yttts = require("yt-search");
  const chalk = require('chalk')
  const moment = require('moment-timezone')
  const clc = require('cli-color')
  const hx = require("hxz-api")
  const NodeCache = require('node-cache');
  const uber = require('uberduck-api')
  const cheerio = require("cheerio");
  const readline = require("readline");
  const axios = require('axios');
  const ffmpeg = require('fluent-ffmpeg');
  const thiccysapi = require('textmaker-thiccy');
  ///////////////////////////////////////////////
  let bancht = JSON.parse(fs.readFileSync('./functions/banchat.json'));
  const linkNeroV1 = JSON.parse(fs.readFileSync("./functions/fotos/logo.json"))
  const infoBot = JSON.parse(fs.readFileSync('./config.json'));
  ///////////////////////////////////////////////
  const imagemdomenu = "https://imgur.com/YdWw6qd?r"
  //  "https://telegra.ph/file/899eeb68fbedb64c2d926.jpg"
  const { palavras } = require('./functions/conselhos.js');
  const { ytv } = require('./functions/y2mate.js')
  const { fromBuffer } = require("file-type");
  //const { ia } = require('./datab/js/ia')
  //const welcome_group = JSON.parse(fs.readFileSync('./functions/welcomegp.json'));
  //const writeExifImg = require("./functions/exif")
  const bye_group2 = JSON.parse(fs.readFileSync('./functions/byegp.json'));
  const { insert, response } = require('./functions/simi.js');
  ///////////////////////////////////////////////
  const premium = JSON.parse(fs.readFileSync('./functions/premium.json'));
  const { Youtube } = require('ytdownloader.js')
  const antidoc = JSON.parse(fs.readFileSync('./functions/antidoc.json'))
  const antiimg = JSON.parse(fs.readFileSync('./functions/antiimg.json'))
  const lista = JSON.parse(fs.readFileSync('./functions/lista.json'))
  const sotoy = JSON.parse(fs.readFileSync('./functions/sotoy.json'))
  const antiaudio = JSON.parse(fs.readFileSync('./functions/antiaudio.json'))
  const antisticker = JSON.parse(fs.readFileSync('./functions/antisticker.json'))
  const antivid = JSON.parse(fs.readFileSync('./functions/antivideo.json'))
  const autoreact = JSON.parse(fs.readFileSync('./functions/autoreact.json'))

  ///////////////////////////////////////////////
  const { runtime } = require("./functions/myfunc")
  const { convertSticker } = require("./functions/swm.js");
  const { isUrl } = require("./functions/lib/myfunc.js")
  const { EmojiAPI } = require("emoji-api")
  const autofigu = JSON.parse(fs.readFileSync('./functions/autofigu.json'))
  const usedCommandRecently = new Set()
  let autosticker = JSON.parse(fs.readFileSync('./functions/autosticker.json'));
  const { menuprem } = require("./functions/menuprem.js")
  const { palavrasANA, quizanime, quizanimais } = require('./functions/jogos.js');
  const { exec, spawn, execSync } = require("child_process")
  const speed = require("performance-now");
  const sleep = async (ms) => { return new Promise(resolve => setTimeout(resolve, ms)) }
  const { getBuffer, getRandom, getExtension } = require('./functions/lib/functions.js');
  const { fetchJson } = require("./functions/lib/fetcher")
  const { validmove, setGame } = require('./functions/tictactoe');
  const { TextoDoBemvindo } = require("./info/TextoDoBemvindo.js")
  const { TextoDoSaiu } = require("./info/TextoDoBemvindo.js")
  const { Aki } = require('aki-api')
  const { Error } = JSON.parse(fs.readFileSync('./functions/Erro.json'))

  ///////////////////////////////////////////////

  //====== defina ======\\

  var prefix = infoBot.prefix //prefixo 

  var nomeBot = infoBot.nomeBot// nome do bot 

  var NomeBot = infoBot.nomeBot// nome do bot 

  var nomeDono = infoBot.nomeDono// nome do dono 

  var SoDono = infoBot.numeroDono

  var link = infoBot.link

  logo = linkNeroV1.logo

  var numeroDono = infoBot.numeroDono

  ///////////////////////////////////////////////
  const groupIdWelcomed = []
  const welcome_group = JSON.parse(fs.readFileSync('./functions/welcomegp.json'));
  const antipv = JSON.parse(fs.readFileSync('./functions/antipv.json'))
  const antilinkgp = JSON.parse(fs.readFileSync('./functions/antilinkgp.json'))
  const welkom = JSON.parse(fs.readFileSync('./functions/welkom.json'));
  const time = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

  const hora = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

  const date = moment.tz('America/Sao_Paulo').format('DD/MM/YY');

  const welkom2 = JSON.parse(fs.readFileSync('./functions/welkom.json'));
  const welcome_group2 = JSON.parse(fs.readFileSync('./functions/welcomegp.json'));
  const color = (text, color) => {
    return !color ? chalk.green(text) : chalk.keyword(color)(text)
  }
  const cfonts = require('cfonts')

  const useStore = !process.argv.includes('--no-store')
  const doReplies = !process.argv.includes('--no-reply')
  const useMobile = process.argv.includes('--mobile')
  const usePairingCode = process.argv.includes('--use-pairing-code')
  const msgRetryCounterCache = new NodeCache();
  const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
  });
  async function starts() {
    const { state, saveCreds } = await useMultiFileAuthState('./WhatsApp-Conexao')
    const { version } = await fetchLatestBaileysVersion();
    const question = (text) => new Promise((resolve) => rl.question(text, resolve));
    const store = makeInMemoryStore({
      logger: P().child({
        level: 'debug',
        stream: 'store'
      })
    })

    const client = makeWASocket({
        version,
        logger: P({ level: "silent" }),
        usePairingCode,
        mobile: false,
        browser: ["FireFox (linux)"],
        auth: state,
        msgRetryCounterCache,
        defaultQueryTimeoutMs: undefined,
        patchMessageBeforeSending: (message) => {
            const requiresPatch = !!(message.buttonsMessage || message.listMessage);
            if (requiresPatch) {
                message = {
                    viewOnceMessage: {
                        message: {
                            messageContextInfo: {
                                deviceListMetadataVersion: 2,
                                deviceListMetadata: {},
                            }, ...message
                        }
                    }
                }
            }
            return message;
        }
    });

    //console.log(banner.string)
    console.log('[ Rip 6.0 online ]')
    
function limparNumero(entrada) {
    const numeros = entrada.replace(/\D/g, '');
    const numeroLimpo = numeros.replace(/^(\d{2})(9)?(\d{8,9})$/, '$1$3');
    return numeroLimpo;
}

    if (!client.authState.creds.registered) {
        const phoneNumber = await question(`\nDigite seu n√∫mero do WhatsApp:\nEx: ${clc.bold("+55 75 9865-6060")}\n `);
const numeroLimpo = limparNumero(phoneNumber);
        const code = await client.requestPairingCode(numeroLimpo);
        console.log(`Seu c√≥digo de conex√£o √©: \n\n ${clc.bold(code)}\n~>`);
        console.log(`Abra seu WhatsApp, v√° em ${clc.bold("Aparelhos Conectados > Conectar um novo Aparelho > Conectar usando N√∫mero.")}`)
    }

    store.bind(client.ev)

    client.ev.on("creds.update", saveCreds)
    store.bind(client.ev)
    client.ev.on("chats.set", () => {
        console.log("Tem conversas", store.chats.all())
    })
    client.ev.on("contacts.set", () => {
        console.log("Tem contatos", Object.values(store.contacts))
    })
    // CONEX√ÉO ATUALIZA√á√ÉO 
    client.ev.on("connection.update", (update) => {
        const { connection, lastDisconnect } = update
        if (connection === "close") {
            const shouldReconnect = (lastDisconnect.error)?.output?.statusCode !== DisconnectReason.loggedOut
            console.log("Conex√£o fechada devido a", lastDisconnect.error, "Tentando reconectar...", shouldReconnect);
            if (shouldReconnect) {
                starts()
            }

        } else if (connection === "open") {
            console.log(chalk.keyword("red")("Conectado com sucesso!"));
        }
    })
    // Evento de mensagem



    function DLT_FL(file) {
      try {
        fs.unlinkSync(file);
      } catch (error) {
        return;
      }
    }

    ///////////////////////////////////////////////
    //FUN√á√ÉO DO BEM VINDO//
    ///////////////////////////////////////////////
    const time = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

    const hora = moment.tz('America/Sao_Paulo').format('HH:mm:ss');

    const date = moment.tz('America/Sao_Paulo').format('DD/MM/YY');

    client.ev.on('group-participants.update', async (anu) => {
      ale = anu
      conn = client

      const grpmdt = await client.groupMetadata(ale.id);

      const isGroup2 = grpmdt.id.endsWith('@g.us');

      const GroupMetadata_ = isGroup2 ? await client.groupMetadata(ale.id) : "";
      const mdata_ = isGroup2 ? await client.groupMetadata(ale.id) : "";


      if (welkom2.includes(ale.id)) {
        //if(antifake.includes(ale.id) && !ale.participants[0].startsWith(55)) return
        try {
          let metadata = await client.groupMetadata(anu.id)
          let participants = anu.participants
          for (let num of participants) {

            try {
              ppimg = await client.profilePictureUrl(anu.participants[0])
            } catch {
              ppimg = 'https://telegra.ph/file/b5427ea4b8701bc47e751.jpg'
            }

            memb = metadata.participants.length

            if (anu.action == 'add') {
              num = anu.participants[0]

              client.sendMessage(anu.id, {
                image: { url: imagemdomenu }, caption: `‚ù§Bem‚ô§vindo(a) ùò¢ùò∞ ùò®ùò≥ùò∂ùò±ùò∞:\n*${metadata.subject}*\nLEIA REGRAS E SEJA BEM VINDO(A)\n\n\n${NomeDoBot}`, headerType: 4
              })
            } else if (anu.action == 'remove') {
              client.sendMessage(anu.id, { image: { url: imagemdomenu }, caption: `OLA POVO DO GRUPO:\n*${metadata.subject}*\n\nO Membro: @${num.split('@')[0]}\n\nSaiu do Grp ou foi Banido.` })
            }
          }
        } catch (err) {
          console.log(err)
        }

      }

    })


    // MENSAGEM ATUALIZA√á√ÉO 
    client.ev.on('messages.upsert', async connection => {
      //console.log(connection)
      const info = connection.messages[0];
      //if (info.key.fromMe) return;
      if (connection.type != 'notify') return;
      if (info.key.remoteJid === 'status@broadcast') return;
      try {
        function getGroupAdmins(participants) {
          admins = []
          for (let i of participants) {
            if (i.admin == 'admin') admins.push(i.id)
            if (i.admin == 'superadmin') admins.push(i.id)
          }
          return admins
        }
        const getRandom = (ext) => {
          return `${Math.floor(Math.random() * 10000)}${ext}`
        }
        const getExtension = async (type) => {
          return await mimetype.extension(type)
        }
        const getBuffer = (url, options) => new Promise(async (resolve, reject) => {
          options ? options : {}
          await axios({ method: "get", url, headers: { "DNT": 1, "Upgrade-Insecure-Request": 1 }, ...options, responseType: "arraybuffer" }).then((res) => {
            resolve(res.data)
          }).catch(reject)
        })

        ///////////////////////////////////////////////
        //**************[ functions ]**************//
        ///////////////////////////////////////////////

        const donoOficial = [`@s.whatsapp.net`]
        //const info = msg.messages[0]
        if (!info.message) return
        if (info.key && info.key.remoteJid == 'status@broadcast') return
        const type = Object.keys(info.message)[0] == 'senderKeyDistributionMessage' ? Object.keys(info.message)[2] : (Object.keys(info.message)[0] == 'messageContextInfo') ? Object.keys(info.message)[1] : Object.keys(info.message)[0]
        const content = JSON.stringify(info.message);
        const altpdf = Object.keys(info.message)
        global.prefix
        const from = info.key.remoteJid
        var body = info.message?.conversation || info.message?.viewOnceMessageV2?.message?.imageMessage?.caption || info.message?.viewOnceMessageV2?.message?.videoMessage?.caption || info.message?.imageMessage?.caption || info.message?.videoMessage?.caption || info.message?.extendedTextMessage?.text || info.message?.viewOnceMessage?.message?.videoMessage?.caption || info.message?.viewOnceMessage?.message?.imageMessage?.caption || info.message?.documentWithCaptionMessage?.message?.documentMessage?.caption || info.message?.buttonsMessage?.imageMessage?.caption || info.message?.buttonsResponseMessage?.selectedButtonId || info.message?.listResponseMessage?.singleSelectReply?.selectedRowId || info.message?.templateButtonReplyMessage?.selectedId || info?.text || ""

        const budy = (type === 'conversation') ? info.message.conversation : (type === 'extendedTextMessage') ? info.message.extendedTextMessage.text : ''
        const reply = (text) => {
          client.sendMessage(from, { text: text }, { quoted: info })
        }





        const menc_prt = info.message?.extendedTextMessage?.contextInfo?.participant
        var pes = (type === 'conversation' && info.message.conversation) ? info.message.conversation : (type == 'imageMessage') && info.message.imageMessage.caption ? info.message.imageMessage.caption : (type == 'videoMessage') && info.message.videoMessage.caption ? info.message.videoMessage.caption : (type == 'extendedTextMessage') && info.message.extendedTextMessage.text ? info.message.extendedTextMessage.text : ''
        const quoted = info.quoted ? info.quoted : info
        ///////////////////////////////////////////////
        //********IS DO ANTIPV***********\\
        ///////////////////////////////////////////////
        const isAntiPv = (antipv.indexOf('Ativado') >= 0) ? true : false
        ///////////////////////////////////////////////
        //*****functions DO ANAGRAMA E LEVEL*******
        ///////////////////////////////////////////////

        const pushname = info.pushName ? info.pushName : ''
        const username = info.username ? info.username : ''
        const _level = JSON.parse(fs.readFileSync('./functions/level.json'))
        const addLevelingXp = (userId, amount) => {
          let position = false
          Object.keys(_level).forEach((i) => {
            if (_level[i].jid === userId) {
              position = i
            }
          })
          if (position !== false) {
            _level[position].xp += amount
            fs.writeFileSync('./functions/level.json', JSON.stringify(_level))
          }
        }
        const isGroup = info.key.remoteJid.endsWith('@g.us')
        const sender = isGroup ? info.key.participant : info.key.remoteJid
        if (isGroup && fs.existsSync(`./functions/anagrama-${from}.json`)) {
          let dataAnagrama = JSON.parse(fs.readFileSync(`./functions/anagrama-${from}.json`))
          if (budy.slice(0, 4).toUpperCase() == dataAnagrama.original.slice(0, 4).toUpperCase() && budy.toUpperCase() != dataAnagrama.original) return reply('est√° perto')
          xp = Math.floor(Math.random() * 14) + 3000
          if (budy.toUpperCase() == dataAnagrama.original) {

            let ano = {
              image: { url: logo },
              caption: `
  parab√©ns ${pushname} ü•≥ voc√™ ganhou o jogo\nPalavra : ${dataAnagrama.original}\nIniciando o proximo jogo em 5 segundos..
  `,
              lfooter: "",
              //buttons: buttons,
              headerType: 4
            }

            client.sendMessage(from, ano, { "mentionedJid": [sender] }), fs.unlinkSync(`./functions/anagrama-${from}.json`)
            addLevelingXp(sender, xp)
            recompensa = `üéâüéâRECOMPENSAüéâüéâ\nVoc√™ ganhou ${xp} em *xp*`
            reply(recompensa)
            setTimeout(async () => {
              fs.writeFileSync(`./functions/anagrama-${from}.json`, `${JSON.stringify(palavrasANA[Math.floor(Math.random() * palavrasANA.length)])}`)
              let dataAnagrama2 = JSON.parse(fs.readFileSync(`./functions/anagrama-${from}.json`))

              let ani = {
                image: { url: logo },
                caption: `
  ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚âΩ„Äå üëæ ANAGRAMA üëæ „Äç
  ‚îÇüçâ‚ûΩ DESCUBRA A PALAVRA
  ‚îÇüçâ‚ûΩ ANAGRAMA: ${dataAnagrama2.embaralhada}
  ‚îÇüçâ‚ûΩ DICA: ${dataAnagrama2.dica}
  ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  `,
                lfooter: `${nomeBot}`,
                //buttons: buttons,
                headerType: 4
              }

              client.sendMessage(from, ani)
            }, 5000)
          }
        }
        ///////////////////////////////////////////////
        //DEFINI√á√ïES DO LEVELING
        ///////////////////////////////////////////////

        const anuncio = (text) => {
          client.sendMessage(from, {
            text: text,
            contextInfo: {
              "externalAdReply": {
                title: `${NomeDoBot}`,
                mediaType: 1,
                renderLargerThumbnail: false,
                showAdAttribution: true,
                body: `ùë©ùíö ${nomeDono}`,
                thumbnail: { url: `https://telegra.ph/file/899eeb68fbedb64c2d926.jpg` },
                mediaUrl: `${q}`,
                sourceUrl: `${q}`,
                headerType: 4
              }
            }
          })
        }

        const _leveling = JSON.parse(fs.readFileSync('./functions/lib/leveling.json'))
        const levelingOn = JSON.parse(fs.readFileSync('./functions/lib/leveling.json'))
        const isLevelingOn = isGroup ? _leveling.includes(from) : true
        const { getUserRank, addCooldown, leveltab } = require('./functions/lib/leveling.js')
        const getLevelingXp = (userId) => {
          let position = false
          Object.keys(_level).forEach((i) => {
            if (_level[i].jid === userId) {
              position = i
            }
          })
          if (position !== false) {
            return _level[position].xp
          }
        }
        const getLevelingLevel = (userId) => {
          let position = false
          Object.keys(_level).forEach((i) => {
            if (_level[i].jid === userId) {
              position = i
            }
          })
          if (position !== false) {
            return _level[position].level
          }
        }
        const getLevelingId = (userId) => {
          let position = false
          Object.keys(_level).forEach((i) => {
            if (_level[i].jid === userId) {
              position = i
            }
          })
          if (position !== false) {
            return _level[position].jid
          }
        }


        const addLevelingLevel = (userId, amount) => {
          let position = false
          Object.keys(_level).forEach((i) => {
            if (_level[i].jid === userId) {
              position = i
            }
          })
          if (position !== false) {
            _level[position].level += amount
            fs.writeFileSync('./functions/level.json', JSON.stringify(_level))
          }
        }
        const addLevelingId = (userId) => {
          const obj = { jid: userId, xp: 1, level: 1 }
          _level.push(obj)
          fs.writeFileSync('./functions/level.json', JSON.stringify(_level))
        }
        /********** FUCTION LEVELING **********/
        var per = '*[‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí] 0%*'
        const peri = 5000 * (Math.pow(2, getLevelingLevel(sender)) - 1)
        const perl = peri - getLevelingXp(sender)
        const resl = Math.round(100 - ((perl / getLevelingXp(sender)) * 100))
        if (resl <= 10) {
          per = `*[‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí] ${resl}%*`
        } else if (resl <= 20) {
          per = `*[‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí] ${resl}%*`
        } else if (resl <= 30) {
          per = `*[‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí] ${resl}%*`
        } else if (resl <= 40) {
          per = `*[‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí] ${resl}%*`
        } else if (resl <= 50) {
          per = `*[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí] ${resl}%*`
        } else if (resl <= 60) {
          per = `*[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí] ${resl}%*`
        } else if (resl <= 70) {
          per = `*[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí] ${resl}%*`
        } else if (resl <= 80) {
          per = `*[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí] ${resl}%*`
        } else if (resl <= 90) {
          per = `*[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí] ${resl}%*`
        } else if (resl <= 100) {
          per = `*[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] ${resl}%*`
        }
        const levelRole = getLevelingLevel(sender)
        var role = 'Bronze Iü•â'
        if (levelRole <= 3) {
          role = 'Bronze I ü•â'
        } else if (levelRole <= 5) {
          role = 'Bronze II ü•â'
        } else if (levelRole <= 10) {
          role = 'Bronze III ü•â'
        } else if (levelRole <= 15) {
          role = 'Bronze IV ü•â'
        } else if (levelRole <= 20) {
          role = 'Bronze V ü•â'
        } else if (levelRole <= 25) {
          role = 'Prata I ü•à'
        } else if (levelRole <= 30) {
          role = 'Prata II ü•à'
        } else if (levelRole <= 35) {
          role = 'Prata III ü•à'
        } else if (levelRole <= 40) {
          role = 'Prata IV ü•à'
        } else if (levelRole <= 45) {
          role = 'Prata V ü•à'
        } else if (levelRole <= 50) {
          role = 'Ouro I ü•á'
        } else if (levelRole <= 55) {
          role = 'Ouro II ü•á'
        } else if (levelRole <= 60) {
          role = 'Ouro III ü•á'
        } else if (levelRole <= 65) {
          role = 'Ouro IV ü•á'
        } else if (levelRole <= 70) {
          role = 'Ouro V ü•á'
        } else if (levelRole <= 75) {
          role = 'Campe√£o I üèÜ'
        } else if (levelRole <= 80) {
          role = 'Campe√£o II üèÜ'
        } else if (levelRole <= 85) {
          role = 'Campe√£o III üèÜ'
        } else if (levelRole <= 90) {
          role = 'Campe√£o IV üèÜ'
        } else if (levelRole <= 95) {
          role = 'Campe√£o V üèÜ'
        } else if (levelRole <= 100) {
          role = 'Diamante I üíé'
        } else if (levelRole <= 110) {
          role = 'Diamante II üíé'
        } else if (levelRole <= 120) {
          role = 'Diamante III üíé'
        } else if (levelRole <= 130) {
          role = 'Diamante IV üíé'
        } else if (levelRole <= 140) {
          role = 'Diamante V üíé'
        } else if (levelRole <= 150) {
          role = 'Mestre I üî•'
        } else if (levelRole <= 170) {
          role = 'Mestre II üî•'
        } else if (levelRole <= 180) {
          role = 'Mestre III üî•'
        } else if (levelRole <= 190) {
          role = 'Mestre IV üî•'
        } else if (levelRole <= 200) {
          role = 'Mestre V üî•'
        } else if (levelRole <= 250) {
          role = 'M√≠tico I üîÆ'
        } else if (levelRole <= 300) {
          role = 'M√≠tico II üîÆ'
        } else if (levelRole <= 350) {
          role = 'M√≠tico III üîÆ'
        } else if (levelRole <= 400) {
          role = 'M√≠tico IV üîÆ'
        } else if (levelRole <= 450) {
          role = 'M√≠tico V üîÆ'
        } else if (levelRole <= 500) {
          role = 'Lenda I ‚ö°'
        } else if (levelRole <= 550) {
          role = 'Lenda II ‚ö°'
        } else if (levelRole <= 600) {
          role = 'Lenda III ‚ö°'
        } else if (levelRole <= 650) {
          role = 'Lenda IV ‚ö°'
        } else if (levelRole <= 700) {
          role = 'Lenda V ‚ö°'
        } else if (levelRole <= 750) {
          role = 'Lend√°rio I üéë'
        } else if (levelRole <= 800) {
          role = 'Lend√°rio II üéë'
        } else if (levelRole <= 850) {
          role = 'Lend√°rio III üéë'
        } else if (levelRole <= 900) {
          role = 'Lend√°rio IV üéë'
        } else if (levelRole <= 910) {
          role = 'Lend√°rio V üéë'
        } else if (levelRole <= 920) {
          role = 'EL MESTRE I üèÖ'
        } else if (levelRole <= 930) {
          role = 'EL MESTRE II üèÖ'
        } else if (levelRole <= 940) {
          role = 'EL MESTRE III üèÖ'
        } else if (levelRole <= 950) {
          role = 'EL MESTRE IV üèÖ'
        } else if (levelRole <= 10000) {
          role = '‚ö°Ô∏è BRIGADEIRO ‚ö°Ô∏è'
        }
        if (isGroup && isLevelingOn) {
          const currentLevel = getLevelingLevel(sender)
          const checkId = getLevelingId(sender)
          try {
            if (currentLevel === undefined && checkId === undefined) addLevelingId(sender)
            const amountXp = Math.floor(Math.random() * 10) + 500
            const requiredXp = 10000 * (Math.pow(2, currentLevel) - 1)
            const getLevel = getLevelingLevel(sender)
            addLevelingXp(sender, amountXp)
            if (requiredXp <= getLevelingXp(sender)) {
              addLevelingLevel(sender, 1)
              await client.sendMessage(sender, { text: `*„Äå LEVEL UP „Äç*\n\n‚û∏ *Nome*: ${sender}\n‚û∏ *XP*: ${getLevelingXp(sender)}\n‚û∏ *Level*: ${getLevel} -> ${getLevelingLevel(sender)}\n\nParab√©ns!!  üéâüéâ` })
            }
          } catch (err) {
            console.error(err)
          }
        }
        const getLevel = getLevelingLevel(sender)
        const tictactoe = JSON.parse(fs.readFileSync('./functions/database/tictactoe.json'));
        const registros = JSON.parse(fs.readFileSync("./functions/registros.json"))
        const isRegistro = registros.includes(sender)

        const addTTTId = (userId) => {
          const obj = { jid: userId, wins: 0, defeats: 0, ties: 0, points: 0 }
          tictactoe.push(obj)
          fs.writeFileSync('./functions/database/tictactoe.json', JSON.stringify(tictactoe))
        }

        const addTTTwin = (userId, amount) => {
          let position = false
          Object.keys(tictactoe).forEach((i) => {
            if (tictactoe[i].jid === userId) {
              position = i
            }
          })
          if (position !== false) {
            tictactoe[position].wins += amount
            fs.writeFileSync('./functions/database/tictactoe.json', JSON.stringify(tictactoe))
          }
        }

        const addTTTdefeat = (userId, amount) => {
          let position = false
          Object.keys(tictactoe).forEach((i) => {
            if (tictactoe[i].jid === userId) {
              position = i
            }
          })
          if (position !== false) {
            tictactoe[position].defeats += amount
            fs.writeFileSync('./functions/database/tictactoe.json', JSON.stringify(tictactoe))
          }
        }

        const addTTTtie = (userId, amount) => {
          let position = false
          Object.keys(tictactoe).forEach((i) => {
            if (tictactoe[i].jid === userId) {
              position = i
            }
          })
          if (position !== false) {
            tictactoe[position].ties += amount
            fs.writeFileSync('./functions/database/tictactoe.json', JSON.stringify(tictactoe))
          }
        }

        const addTTTpoints = (userId, amount) => {
          let position = false
          Object.keys(tictactoe).forEach((i) => {
            if (tictactoe[i].jid === userId) {
              position = i
            }
          })
          if (position !== false) {
            tictactoe[position].points += amount
            fs.writeFileSync('./functions/database/tictactoe.json', JSON.stringify(tictactoe))
          }
        }

        const getTTTId = (userId) => {
          let position = false
          Object.keys(tictactoe).forEach((i) => {
            if (tictactoe[i].jid === userId) {
              position = i
            }
          })
          if (position !== false) {
            return tictactoe[position].jid
          }
        }

        const getTTTwins = (userId) => {
          let position = false
          Object.keys(tictactoe).forEach((i) => {
            if (tictactoe[i].jid === userId) {
              position = i
            }
          })
          if (position !== false) {
            return tictactoe[position].wins
          }
        }

        const getTTTdefeats = (userId) => {
          let position = false
          Object.keys(tictactoe).forEach((i) => {
            if (tictactoe[i].jid === userId) {
              position = i
            }
          })
          if (position !== false) {
            return tictactoe[position].defeats
          }
        }

        const getTTTties = (userId) => {
          let position = false
          Object.keys(tictactoe).forEach((i) => {
            if (tictactoe[i].jid === userId) {
              position = i
            }
          })
          if (position !== false) {
            return tictactoe[position].ties
          }
        }

        const getTTTpoints = (userId) => {
          let position = false
          Object.keys(tictactoe).forEach((i) => {
            if (tictactoe[i].jid === userId) {
              position = i
            }
          })
          if (position !== false) {
            return tictactoe[position].points
          }
        }

        ///////////////////////////////////////////////
        // IS DE functions PARA ADM
        ///////////////////////////////////////////////

        const isAntilinkgp = isGroup ? antilinkgp.includes(from) : false
        const Antidoc = isGroup ? antidoc.includes(from) : false
        const isAntiAudio = isGroup ? antiaudio.includes(from) : false
        const isAntiVid = isGroup ? antivid.includes(from) : false
        const isAntiImg = isGroup ? antiimg.includes(from) : false
        const isAntiSticker = isGroup ? antisticker.includes(from) : false
        const isAutoReact = isGroup ? autoreact.includes(from) : false
        const isAutoSticker = isGroup ? autosticker.includes(from) : false
        const isBanchat = isGroup ? bancht.includes(from) : false
        const isWelkom = isGroup ? welkom.includes(from) : false
        const emoji = new EmojiAPI()
        const isPremium = premium.includes(sender)

        ///////////////////////////////////////////////
        //functions PARA COMANDO DE GRUPO
        ///////////////////////////////////////////////

        const groupMetadata = isGroup ? await client.groupMetadata(from) : ''
        const groupName = isGroup ? groupMetadata.subject : ''
        selectedButton = (type == 'buttonsResponseMessage') ? info.message.buttonsResponseMessage.selectedButtonId : ''
        const groupDesc = isGroup ? groupMetadata.desc : ''
        const participants = isGroup ? await groupMetadata.participants : ''
        const groupMembers = isGroup ? groupMetadata.participants : ''
        const groupAdmins = isGroup ? getGroupAdmins(groupMembers) : ''
        const messagesC = pes.slice(0).trim().split(/ +/).shift().toLowerCase()
        const argss = body.split(/ +/g)
        const botNumber = client.user.id.split(':')[0] + '@s.whatsapp.net'
        const args = body.trim().split(/ +/).slice(1);
        const text = args.join(" ")
        const menc_jid = args.join(" ").replace("@", "") + "@s.whatsapp.net"
        const isCmd = body.startsWith(prefix);
        const command = isCmd ? body.slice(1).trim().split(/ +/).shift().toLocaleLowerCase() : null
        const mentions = (teks, memberr, id) => {
          (id == null || id == undefined || id == false) ? client.sendMessage(from, { text: teks.trim(), mentions: memberr }) : client.sendMessage(from, { text: teks.trim(), mentions: memberr })
        }

        const addFilter = (sender) => {
          usedCommandRecently.add(sender)
          setTimeout(() => usedCommandRecently.delete(sender), 4000)
        }


        const groupIdWelcomed = []
        for (let obj of welcome_group) groupIdWelcomed.push(obj.id)

        const groupIdBye = []
        for (let obj of bye_group2) groupIdBye.push(obj.id)

        const isWelcomed = (groupIdWelcomed.indexOf(from) >= 0) ? true : false

        const isByed = (groupIdBye.indexOf(from) >= 0) ? true : false
        ///////////////////////////////////////////////
        //ISQUOTED
        ///////////////////////////////////////////////
        const isImage = type == 'imageMessage'
        const isVideo = type == 'videoMessage'
        const isAudio = type == 'audioMessage'
        const isSticker = type == 'stickerMessage'
        const isContact = type == 'contactMessage'
        const isLocation = type == 'locationMessage'
        const isProduct = type == 'productMessage'
        const isMedia = (type === 'imageMessage' || type === 'videoMessage' || type === 'audioMessage')
        typeMessage = body.substr(0, 50).replace(/\n/g, '')
        if (isImage) typeMessage = "Image"
        else if (isVideo) typeMessage = "Video"
        else if (isAudio) typeMessage = "Audio"
        else if (isSticker) typeMessage = "Sticker"
        else if (isContact) typeMessage = "Contact"
        else if (isLocation) typeMessage = "Location"
        else if (isProduct) typeMessage = "Product"
        const isQuotedMsg = type === 'extendedTextMessage' && content.includes('textMessage')
        const isQuotedImage = type === 'extendedTextMessage' && content.includes('imageMessage')
        const isQuotedVideo = type === 'extendedTextMessage' && content.includes('videoMessage')
        const isQuotedDocument = type === 'extendedTextMessage' && content.includes('documentMessage')
        const isQuotedAudio = type === 'extendedTextMessage' && content.includes('audioMessage')
        const isQuotedSticker = type === 'extendedTextMessage' && content.includes('stickerMessage')
        const isQuotedContact = type === 'extendedTextMessage' && content.includes('contactMessage')
        const isQuotedLocation = type === 'extendedTextMessage' && content.includes('locationMessage')
        const isQuotedProduct = type === 'extendedTextMessage' && content.includes('productMessage')
        const getFileBuffer = async (mediakey, MediaType) => {
          const stream = await downloadContentFromMessage(mediakey, MediaType)
          let buffer = Buffer.from([])
          for await (const chunk of stream) {
            buffer = Buffer.concat([buffer, chunk])
          }
          return buffer
        }
        const isGroupAdmins = groupAdmins.includes(sender) || false
        const isBotGroupAdmins = groupAdmins.includes(botNumber) || false

        ///////////////////////////////////////////////
        //FUN√á√ÉO DE DONO 
        ///////////////////////////////////////////////
        const isOwner = sender.includes(infoBot.numeroDono)
        /////////////////////////////////////////////////


        q = args.join(" ")

        const sendBtext = async (id, text1, desc1, but = [], vr) => {
          buttonMessage = { text: text1, footer: desc1, buttons: but, headerType: 1 }
          client.sendMessage(id, buttonMessage, { quoted: vr })
        }

        const sendBimg = async (id, img1, text1, desc1, but = [], vr) => {
          buttonMessage = { image: { url: img1 }, caption: text1, footerText: desc1, buttons: but, headerType: 4 }
          client.sendMessage(id, buttonMessage, { quoted: vr })
        }

        const sendBimgT = async (id, img1, text1, desc1, but = [], vr) => {
          templateMessage = { image: { url: img1 }, caption: text1, footer: desc1, templateButtons: but, }
          client.sendMessage(id, templateMessage, { quoted: vr })
        }

        const sendGifButao = async (id, gif1, text1, desc1, but = [], vr) => {
          buttonMessage = { video: { url: gif1 }, caption: text1, gifPlayback: true, footerText: desc1, buttons: but, headerType: 4 }
          client.sendMessage(id, buttonMessage, { quoted: vr })
        }
        //*******************************************//


        // VERIFICADOS ‚≠êÔ∏è
        const live = info
        const imgm = info
        const vid = info
        const contato = info
        const doc = info


        const argsButton = selectedButton.trim().split(/ +/)
        const dbids = []
        for (i = 0; i < lista.length; ++i) {
          dbids.push(lista[i].groupId)
        }
        const islista = (isGroup && dbids.indexOf(from) >= 0) ? true : false



        const enviarfigu = async (figu, tag) => {
          bla = fs.readFileSync(figu)
          client.sendMessage(from, { sticker: bla }, { quoted: info })
        }

        const enviarfiguUrl = async (link) => {
          ranp = getRandom('.gif')
          rano = getRandom('.webp')
          ini_buffer = `${link}`
          exec(`wget ${ini_buffer} -O ${ranp} && ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 320:320 ${rano}`, (err) => {
            fs.unlinkSync(ranp)
            buff = fs.readFileSync(rano)
            client.sendMessage(from, { sticker: buff }, { quoted: info }).catch(e => {
            })
            fs.unlinkSync(rano)
          })
        }

        if (isAutoSticker && isGroup) {
          async function autofiguf() {
            await setTimeout(async () => {
              if (budy.includes(`${prefix}sticker`) || budy.includes(`${prefix}s`) || budy.includes(`${prefix}stk`) || budy.includes(`${prefix}st`) || budy.includes(`${prefix}fsticker`) || budy.includes(`${prefix}f`) || budy.includes(`${prefix}fstiker`)) return
              if (type === "videoMessage") {
                if ((isMedia && info.message.videoMessage.seconds < 40)) {
                  rane = getRandom('.' + await getExtension(info.message.videoMessage.mimetype))
                  buffimg = await getFileBuffer(info.message.videoMessage, 'video')
                  fs.writeFileSync(rane, buffimg)
                  const media = rane
                  rano = getRandom('.webp')
                  await ffmpeg(`./${media}`)
                    .inputFormat(media.split('.')[1])
                    .on('start', function (cmd) {
                      console.log(`Started : ${cmd}`)
                    })
                    .on('error', function (err) {
                      console.log(`Error : ${err}`)
                      exec(`webpmux -set exif ${addMetadata('bot', 'manu')} ${rano} -o ${rano}`, async (error) => {
                        fs.unlinkSync(media)
                        tipe = media.endsWith('.mp4') ? 'video' : 'gif'
                        reply(`Falha na convers√£o de ${tipe} para sticker`)
                      })
                    })
                  exec(`ffmpeg -i ${media} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 200:200 ${rano}`, (err) => {
                    fs.unlinkSync(media)
                    buffer = fs.readFileSync(rano)
                    client.sendMessage(from, { sticker: buffer }, { quoted: info })
                    fs.unlinkSync(rano)
                  })
                }
              }

              if (type === "imageMessage") {
                rane = getRandom('.' + await getExtension(info.message.imageMessage.mimetype))
                buffimg = await getFileBuffer(info.message.imageMessage, 'image')
                fs.writeFileSync(rane, buffimg)
                const media = rane
                rano = getRandom('.webp')
                exec(`ffmpeg -i ${media} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${rano}`, (err) => {
                  fs.unlinkSync(media)
                  buffer = fs.readFileSync(rano)
                  client.sendMessage(from, { sticker: buffer }, { quoted: info })
                  fs.unlinkSync(rano)
                })
              }
            }, 1000)
          }
          autofiguf().catch(e => {
            console.log(e)
          })
        }

        var budy2 = body.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

        const isBot = info.key.fromMe ? true : false

        if (isUrl(body) && isAntilinkgp && isGroup && isBotGroupAdmins) {
          if (!isAntilinkgp) return
          if (!isUrl(body)) return
          if (body.includes("http")) {
            if (!budy2.includes("http")) return
            if (isBot) return
            linkgpp = await client.groupInviteCode(from)
            if (budy.match(`${linkgpp}`)) return reply('*Link do nosso grupo, n√£o irei remover.. *')
            if (isGroupAdmins) return reply("*Link detectado, por√©m usu√°rio √© admin*")
            if (!JSON.stringify(groupMembers).includes(sender)) return
            client.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: [sender] } })
            client.groupParticipantsUpdate(from, [sender], 'remove')
          }
        }

        enviar = reply

        const cmde = budy.toLowerCase().split(" ")[0] || "";
        let arrNum = ["1", "2", "3", "4", "5", "6", "7", "8", "9"];

        if (isAutoReact && isGroup && isCmd) {
          if (!isAutoReact) return
          emojis = ["üòÄ", "üòÉ", "üòÅ", "üòÜ", "üòÇ", "ü§£", "üò≠", "üòâ", "üòò", "üòó", "ü•∞", "üòç", "ü§©", "ü•≥", "üôÉ", "üôÇ", "ü•≤", "üòã", "üòõ", "üòú", "üòù", "üòú", "üòá", "üòä", "‚ò∫Ô∏è", "üòè", "üòå", "üòî", "üòë", "üòê", "üò∂", "ü§î", "ü§´", "ü§≠", "ü•±", "ü§ó", "ü§®", "üßê", "üòí", "üôÑ", "üò§", "üò†", "ü§¨", "ü•∫", "üò•", "üòü", "‚òπÔ∏è", "üò¶", "üòß", "üò∞", "üò®", "üòï", "üòØ", "üò≤", "üò≥", "ü§Ø", "üò¨", "üòì", "üòì", "üòû", "üòñ", "ü•¥", "üòé", "ü§ì", "üòé", "ü•µ", "ü•∂", "üåû", "ü§¢", "ü§Æ", "ü§•", "ü§°", "üòà", "ü•µ", "üëΩ", "üò∑", "üí¶", "üë∫", "üëπ", "üí®", "üò∏", "üòπ", "‚ù§Ô∏è", "ü´Ä", "üëÅÔ∏è", "‚ò†Ô∏è", "üíÄ", "üëÄ", "üòª", "üíã", "ü´Ç", "üëÑ", "üëÖ", "üíÖ", "üôè", "ü§≥", "‚úçÔ∏è", "üôÖ", "üåÄ", "‚òÉÔ∏è", "üî•", "‚ö°", "üåà", "üíß", "üôà", "üçë", "üçí", "üçì", "üçå", "üå∂Ô∏è", "üçÜ", "üç¥", "üç∑", "üç¥", "üçΩÔ∏è", "üõ¢Ô∏è", "üö®", "üé§", "üé≠", "üìΩÔ∏è", "üé∞", "‚òéÔ∏è", "üìû", "üëë", "üíé", "üíç", "üíâ", "üóëÔ∏è", "üó°Ô∏è", "‚öîÔ∏è", "üö¨", "üí£", "‚ÅâÔ∏è", "‚úÖ", "üëÅÔ∏è‚Äçüó®Ô∏è", "‚ô•Ô∏è", "üß°", "üíõ", "üíö", "üíô", "üíú", "ü§é", "üñ§", "ü§ç", "üáßüá∑", "üè≥Ô∏è‚Äçüåà", "üá≤üáΩ", "üá™üá∏", "üá≤üáø", "üá¶üá¥", "üá∫üá≤", "ü§î", "ü§´", "üòè", "üçÜ", "üë∫", "üôä"]
          reassao = emojis[Math.floor(Math.random() * emojis.length)]
          sendMsg = await client.sendMessage(from, { react: { text: reassao, key: info.key } })
        }

        if (isAutoReact && isGroup && !isCmd) {
          if (!isAutoReact) return
          emojis = ["üòÄ", "üòÉ", "üòÅ", "üòÜ", "üòÇ", "ü§£", "üò≠", "üòâ", "üòò", "üòó", "ü•∞", "üòç", "ü§©", "ü•≥", "üôÉ", "üôÇ", "ü•≤", "üòã", "üòõ", "üòú", "üòù", "üòú", "üòá", "üòä", "‚ò∫Ô∏è", "üòè", "üòå", "üòî", "üòë", "üòê", "üò∂", "ü§î", "ü§´", "ü§≠", "ü•±", "ü§ó", "ü§®", "üßê", "üòí", "üôÑ", "üò§", "üò†", "ü§¨", "ü•∫", "üò•", "üòü", "‚òπÔ∏è", "üò¶", "üòß", "üò∞", "üò®", "üòï", "üòØ", "üò≤", "üò≥", "ü§Ø", "üò¨", "üòì", "üòì", "üòû", "üòñ", "ü•¥", "üòé", "ü§ì", "üòé", "ü•µ", "ü•∂", "üåû", "ü§¢", "ü§Æ", "ü§•", "ü§°", "üòà", "ü•µ", "üëΩ", "üò∑", "üí¶", "üë∫", "üëπ", "üí®", "üò∏", "üòπ", "‚ù§Ô∏è", "ü´Ä", "üëÅÔ∏è", "‚ò†Ô∏è", "üíÄ", "üëÄ", "üòª", "üíã", "ü´Ç", "üëÑ", "üëÖ", "üíÖ", "üôè", "ü§≥", "‚úçÔ∏è", "üôÖ", "üåÄ", "‚òÉÔ∏è", "üî•", "‚ö°", "üåà", "üíß", "üôà", "üçë", "üçí", "üçì", "üçå", "üå∂Ô∏è", "üçÜ", "üç¥", "üç∑", "üç¥", "üçΩÔ∏è", "üõ¢Ô∏è", "üö®", "üé§", "üé≠", "üìΩÔ∏è", "üé∞", "‚òéÔ∏è", "üìû", "üëë", "üíé", "üíç", "üíâ", "üóëÔ∏è", "üó°Ô∏è", "‚öîÔ∏è", "üö¨", "üí£", "‚ÅâÔ∏è", "‚úÖ", "üëÅÔ∏è‚Äçüó®Ô∏è", "‚ô•Ô∏è", "üß°", "üíõ", "üíö", "üíô", "üíú", "ü§é", "üñ§", "ü§ç", "üáßüá∑", "üè≥Ô∏è‚Äçüåà", "üá≤üáΩ", "üá™üá∏", "üá≤üáø", "üá¶üá¥", "üá∫üá≤", "ü§î", "ü§´", "üòè", "üçÜ", "üë∫", "üôä"]
          reassao = emojis[Math.floor(Math.random() * emojis.length)]
          sendMsg = await client.sendMessage(from, { react: { text: reassao, key: info.key } })
        }

        const samih2 = JSON.parse(fs.readFileSync('./functions/simi.json'));

        const isSimi2 = isGroup ? samih2.includes(from) : false


        if (!isCmd && isSimi2 && isGroup) {
          if (isCmd || isUrl(budy2)) return
          if (budy.length >= 500) return
          if (budy.includes("@55")) return
          if (info.key.fromMe) return
          if (type == 'extendedTextMessage' && prefix.includes(info.message.extendedTextMessage.contextInfo.quotedMessage.conversation[0])) return
          insert(type, info)
          const sami = await response(budy)

          if (sami) client.sendMessage(from, { text: sami, thumbnail: imagemdomenu }, { quoted: info });
        }





        async function upload(Path) {
          return new Promise(async (resolve, reject) => {
            if (!fs.existsSync(Path)) return reject(new Error("File not Found"))
            try {
              const form = new BodyForm();
              form.append("file", fs.createReadStream(Path))
              const data = await axios({
                url: "https://telegra.ph/upload",
                method: "POST",
                headers: {
                  ...form.getHeaders()
                },
                data: form
              })
              return resolve("https://telegra.ph" + data.data[0].src)
            } catch (err) {
              return reject(new Error(String(err)))
            }
          })
        }

        function writeExifImg(media, metadata) {
          let wMedia = imageToWebp(media)
          const tmpFileIn = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`)
          const tmpFileOut = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`)
          fs.writeFileSync(tmpFileIn, wMedia)

          if (metadata.packname || metadata.author) {
            const img = new webp.Image()
            const json = { "sticker-pack-id": `https://github.com/DikaArdnt/Hisoka-Morou`, "sticker-pack-name": metadata.packname, "sticker-pack-publisher": metadata.author, "emojis": metadata.categories ? metadata.categories : [""] }
            const exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00])
            const jsonBuff = Buffer.from(JSON.stringify(json), "utf-8")
            const exif = Buffer.concat([exifAttr, jsonBuff])
            exif.writeUIntLE(jsonBuff.length, 14, 4)
            img.load(tmpFileIn)
            fs.unlinkSync(tmpFileIn)
            img.exif = exif
            img.save(tmpFileOut)
            return tmpFileOut
          }
        }

        if (isAntiSticker && isBotGroupAdmins && type == 'stickerMessage') {
          if (isGroupAdmins) return client.sendMessage(from, { text: 'üçâMENSAGEM PROIBIDA,POREM A REALEZA E ADM, ENTAO NAO TE REMOVEREIüçâ' }, { quoted: info })
          await client.sendMessage(from, { text: 'ü•ãMENSAGEM PROIBIDA,PUNINDO USU√ÅRIOü•ã' }, { quoted: info })
          setTimeout(async function () {
            client.groupParticipantsUpdate(from, [sender], 'remove')
          }, 1000)
        }

        if (isAntiImg && isBotGroupAdmins && type == 'imageMessage') {
          if (isGroupAdmins) return client.sendMessage(from, { text: 'üçâMENSAGEM PROIBIDA,POREM A REALEZA E ADM, ENTAO NAO TE REMOVEREIüçâ' }, { quoted: info })
          await client.sendMessage(from, { text: 'ü•ãMENSAGEM PROIBIDA,PUNINDO USU√ÅRIOü•ã' }, { quoted: info })
          setTimeout(async function () {
            client.groupParticipantsUpdate(from, [sender], 'remove')
          }, 1000)
        }

        if (isAntiVid && isBotGroupAdmins && type == 'videoMessage') {
          if (isGroupAdmins) return client.sendMessage(from, { text: 'üçâMENSAGEM PROIBIDA,POREM A REALEZA E ADM, ENTAO NAO TE REMOVEREIüçâ' }, { quoted: info })
          await client.sendMessage(from, { text: 'ü•ãMENSAGEM PROIBIDA,PUNINDO USU√ÅRIOü•ã' }, { quoted: info })
          setTimeout(async function () {
            client.groupParticipantsUpdate(from, [sender], 'remove')
          }, 1000)
        }

        if (Antidoc && isBotGroupAdmins && type == 'documentMessage') {
          if (isGroupAdmins) return client.sendMessage(from, { text: 'üçâMENSAGEM PROIBIDA,POREM A REALEZA E ADM, ENTAO NAO TE REMOVEREIüçâ' }, { quoted: info })
          await client.sendMessage(from, { text: 'ü•ãMENSAGEM PROIBIDA,PUNINDO USU√ÅRIOü•ã' }, { quoted: info })
          setTimeout(async function () {
            client.groupParticipantsUpdate(from, [sender], 'remove')
          }, 1000)
        }

        if (isAntiPv && !isGroup && !isOwner) {
          msgpvblock = `./func/call/msg_block-${sender}.json`
          fs.writeFileSync(msgpvblock, JSON.stringify("_- PROGRAMA√á√ÉO DE - _\n\n BLOQUEAR / USUARIOS POR ENVIAR MENSAGEM PARA O BOT\n\n_- REALIZANDO A√á√ÉO _-", null, 2))
          msgmsglbl = JSON.parse(fs.readFileSync(msgpvblock))
          reply(msgmsglbl)
          fs.unlinkSync(msgpvblock)
          setTimeout(async () => {
            client.updateBlockStatus(sender, 'block')
          }, 22)
          return
        }

        if (isBanchat && !isGroupAdmins && !isOwner) {
          if (!isGroupAdmins && !isOwner) return
          if (budy.toLowerCase().startsWith('unbangp')) {
            if (isCmd && !isBanchat && !isGroupAdmins) return reply(`Este grupo esta banido!`)
            let lfd = bancht.indexOf(from)
            bancht.splice(lfd, 1)
            fs.writeFileSync('./functions/banchat.json', JSON.stringify(bancht))
            reply(`Grupo desbanido...`)
          }
        }

        if (isAntiAudio && isBotGroupAdmins && type == 'audioMessage') {
          if (isGroupAdmins) return client.sendMessage(from, { text: 'üçâMENSAGEM PROIBIDA,POREM A REALEZA E ADM, ENTAO NAO TE REMOVEREIüçâ' }, { quoted: info })
          await client.sendMessage(from, { text: 'ü•ãMENSAGEM PROIBIDA,PUNINDO USU√ÅRIOü•ã' }, { quoted: info })
          setTimeout(async function () {
            client.groupParticipantsUpdate(from, [sender], 'remove')
          }, 1000)
        }


        // RESPOSTAS DOS COMANDOS \\
        resposta = {
          espere: "[‚öôÔ∏èÔ∏è]Aguarde...enviando ",
          aguarde: "[‚öôÔ∏èÔ∏è]Aguarde...enviando ",
          dono: "[‚öôÔ∏èÔ∏è]Esse comando so pode ser usado pelo meu dono!!! ",
          grupo: "[‚öôÔ∏èÔ∏è]Esse comando s√≥ pode ser usado em grupo ",
          premium: "[‚öôÔ∏èÔ∏è]comando so pra usu√°rios premium",
          privado: "[‚öôÔ∏èÔ∏è]Esse comando s√≥ pode ser usado no privado ",
          adm: "[‚öôÔ∏èÔ∏è]Esse comando s√≥ pode ser usado por administradores de grupo",
          botadm: "[‚öôÔ∏èÔ∏è]Este comando s√≥ pode ser usado quando o bot se torna administrador ",
          registro: `[‚öôÔ∏èÔ∏è] Voc√™ n√£o se registrou utilize ${prefix}login para se registrar `,
          norg: "[‚öôÔ∏èÔ∏è] Voc√™ ja est√° registrado ",
          erro: "[‚öôÔ∏èÔ∏è] Error, tente novamente mais tarde ",
          menu: "aaaaa"
        }

        comando = command
        
        if (isGroup) {
          if (isCmd && !isBot) {
            console.log(
              color(`\n ‚Äúùòîùò¶ùò¥ùò¢ùò®ùò¶ùòÆ ùò¶ùòÆ ùò®ùò≥ùò∂ùò±ùò∞ ‚Äù`, 'blue'),
              color(`\n‚û± üçâùô≤ùôæùôºùô∞ùôΩùô≥ùôæ: ${comando}`, 'red'),
              color(`\n‚û± üçâùôΩùöÑÃÅùôºùô¥ùöÅùôæ: ${sender.split("@")[0]}`, 'red'),
              color(`\n‚û± üçâùô∂ùöÅùöÑùôøùôæ: ${groupName}`, 'red'),
              color(`\n‚û± üçâùôΩùôæùôºùô¥: ${pushname}`, 'red'),
              color(`\n‚û± üçâùô∑ùôæùöÅùô∞: ${hora}\n`, 'red'))
          } else if (!isBot) {
            console.log(
              color(`\n ‚Äúùòîùò¶ùò¥ùò¢ùò®ùò¶ùòÆ ùò¶ùòÆ ùò®ùò≥ùò∂ùò±ùò∞ ‚Äù`, 'blue'),
              color(`\n‚û± üçâùôΩùöÑÃÅùôºùô¥ùöÅùôæ: ${color('N√£o', 'red')}`, 'orange'),
              color(`\n‚û± üçâùôΩùöÑÃÅùôºùô¥ùöÅùôæ: ${sender.split("@")[0]}`, 'red'),
              color(`\n‚û± üçâùô∂ùöÅùöÑùôøùôæ: ${groupName}`, 'red'),
              color(`\n‚û± üçâùôΩùôæùôºùô¥: ${pushname}`, 'red'),
              color(`\n‚û± üçâùô∑ùôæùöÅùô∞: ${hora}\n`, 'red'))
          }
        } else {
          if (isCmd && !isBot) {
            console.log(
              color(`\n ‚Äúùòîùò¶ùò¥ùò¢ùò®ùò¶ùòÆ ùòØùò∞ ùò±ùò≥ùò™ùò∑ùò¢ùò•ùò∞‚Äù`, 'blue'),
              color(`\n‚û± üçâùô≤ùôæùôºùô∞ùôΩùô≥ùôæ: ${comando}`, 'red'),
              color(`\n‚û± üçâùôΩùöÑÃÅùôºùô¥ùöÅùôæ: ${sender.split("@")[0]}`, 'red'),
              color(`\n‚û± üçâùôΩùôæùôºùô¥: ${pushname}`, 'red'),
              color(`\n‚û± üçâùô∑ùôæùöÅùô∞: ${hora}\n`, 'red'))
          } else if (!isBot) {
            console.log(
              color(`\n ‚Äúùòîùò¶ùò¥ùò¢ùò®ùò¶ùòÆ ùòØùò∞ ùò±ùò≥ùò™ùò∑ùò¢ùò•ùò∞‚Äù`, 'blue'),
              color(`\n‚û± üçâùô≤ùôæùôºùô∞ùôΩùô≥ùôæ: ${color('N√£o', 'red')}`, 'orange'),
              color(`\n‚û± üçâùôΩùöÑÃÅùôºùô¥ùöÅùôæ: ${sender.split("@")[0]}`, 'red'),
              color(`\n‚û± üçâùôΩùôæùôºùô¥: ${pushname}`, 'red'),
              color(`\n‚û± üçâùô∑ùôæùöÅùô∞: ${hora}\n`, 'red'))
          }
        }

        /*
        if(!isGroup && !isOwner && !m.key.fromMe && !isPremium){ 
        reply(`[üö´] ùóîùó°ùóßùóúùó£ùó© ùó§ùó®ùóò ùóïùóüùó¢ùó§ùó®ùóòùóúùóî! [üö´]\nUsu√°rios que enviarem mensagem no privado, ser√° bloqueado pois antipv est√° ativo, fale com meu dono para solicitar o desbloqueio: wa.me/${numerodn}`)
        setTimeout(async () => {
        //pl.updateBlockStatus(sender, 'block')
        }, 1000)
        return
        }
        */

        const { pix } = require('@klawdyo/pix.js');
        switch (command) {



          case "rip":
          case 'simih2':
          case 'autoresponder':
          case "simi":
            if (!isGroupAdmins) return reply('so adm!!!')
            if (args.length < 1) return reply('1 pra ligar e pra desligar')
            if (Number(args[0]) === 1) {
              if (isSimi2) return reply('O modo Simi est√° ativo')
              samih2.push(from)
              fs.writeFileSync('./functions/simi.json', JSON.stringify(samih2))
              reply('Ativado com sucesso o modo simi neste grupo üòó, Este simih2 ele aprende as respostas e perguntas das pessoas, conforme vai falando, por isso, s√≥ recomendo utilizar ele no termux, pois no site ou lugar diferente do termux que voc√™ utilizar, ele n√£o vai armazenar os dados nescessarios')
            } else if (Number(args[0]) === 0) {
              if (!isSimi2) return reply('J√° est√° Desativado.')
              pesquisar = from
              processo = samih2.indexOf(pesquisar)
              while (processo >= 0) {
                samih2.splice(processo, 1)
                processo = samih2.indexOf(pesquisar)
              }
              fs.writeFileSync('./functions/simi.json', JSON.stringify(samih2))
              reply('Desativado modo simi com sucesso neste grupo üò°Ô∏è')
            } else {
              reply('1 para ativar, 0 para desativar, lerdao vc em KKKKK')
            }
            break



          //case 'play_video':
          case 'ytmp4':
            try {
              if (!q) return reply(`Àñ‚∏ôÃ≠‚ùõ‚ú∞‚ù§Ô∏èColoque um link do YouTube pata o bot baixar`)
              client.sendMessage(from, { react: { text: 'üïö', key: info.key } })
              var url = q;
              var anikit = await fetchJson(`https://fine-gold-squid-yoke.cyclic.app/anikit/ytmp4?username=Teste&key=teste&videoUrl=${url}`)
              client.sendMessage(from,
                {
                  video: { url: anikit.url },
                  mimetype: 'video/mp4'
                })
            } catch (e) {
              return reply("ERROR!!");
              console.log(e)
            }
            break


          //case 'play_audio':
          case 'ytmp3':
            try {
              if (!q) return reply(`Àñ‚∏ôÃ≠‚ùõ‚ú∞‚ù§Ô∏èColoque um link do YouTube pata o bot baixar`)
              client.sendMessage(from, { react: { text: 'üïö', key: info.key } })
              var url = q;
              var anikit = await fetchJson(`https://fine-gold-squid-yoke.cyclic.app/anikit/ytmp3?username=Teste&key=teste&videoUrl=${url}`)
              client.sendMessage(from,
                {
                  audio: { url: anikit.url },
                  mimetype: 'audio/mpeg'
                })
            } catch (e) {
              return reply("ERROR!!");
              console.log(e)
            }
            break

          case 'play_video':
      case 'play-v√≠deo':
      case 'play-video': {
      const anikit = require("trevo-api")
        if (!args.join(' ' < 1)) return reply("Coloque o nume do video junto ou o link mas tem que ser do youtube...")
        const pedido = args.join('');
        reply("enviando...")
        fetch(`https://happy-red-hummingbird.cyclic.app/anikit/playmp4?query=vmz%20baka&username=Teste&key=teste`)
.then(response => response.json()).then(data => {
client.sendMessage(from, { video: { url: response.url } });
})
       
      } break

          case 'play_audio':
      case 'play-√°udio':
      case 'play-audio': {
      const anikit = require("trevo-api")
        if (!args.join(' ' < 1)) return reply("Coloque o nume do video junto ou o link mas tem que ser do youtube...")
        const pedido = args.join('');
        reply("enviando...")
        fetch(`https://happy-red-hummingbird.cyclic.app/anikit/playmp3?query=vmz%20baka&username=Teste&key=teste`)
.then(response => response.json()).then(data => {
client.sendMessage(from, { audio: { url: response.url }, mimetype: 'audio/mpeg' });
})
      } break


          case 'emoji2':
          case 'emoji-mix':
          case 'emojimix': {
            if (!q) return reply(`Exemplo : ${prefix + command} üòÖ+ü§î`)
            reply('SER N√ÉO FOR TENTA COM OUTRO... ?')
            let [emoji1, emoji2] = q.split`+`
            var em = await fetchJson(`https://tenor.googleapis.com/v2/featured?key=AIzaSyAyimkuYQYF_FXVALexPuGQctUWRURdCYQ&contentfilter=high&media_filter=png_transparent&component=proactive&collection=emoji_kitchen_v5&q=${encodeURIComponent(emoji1)}_${encodeURIComponent(emoji2)}`)
            for (let res of em.results) {
              templateMassage = {
                image: {
                  url: `${res.url}`,
                  quoted: live
                }
              }
              client.sendMessage(from, templateMassage, { quoted: live })
            }
          }
            break

          case 'gerarlink':
          case 'imgpralink':
          case "telegra.ph":
            try {
              if (isQuotedImage) {
                boij = isQuotedImage || isQuotedVideo ? JSON.parse(JSON.stringify(info).replace("quotedM", "m")).message.extendedTextMessage.contextInfo.message.imageMessage : info
                const fetch = require('node-fetch');
                const FormData = require('form-data');
                const fs = require('fs');
                async function uploadImageToTelegraph(imageBuffer) {
                  const form = new FormData();
                  form.append('file', imageBuffer, { filename: 'image.jpg' });

                  const response = await fetch('https://telegra.ph/upload', {
                    method: 'POST',
                    body: form,
                  });
                  const data = await response.json();
                  if (data && data[0] && data[0].src) {
                    return 'https://telegra.ph' + data[0].src;
                  } else {
                    throw new Error('Failed to retrieve the image URL from the response.');
                  }
                }
                const owgi = await getFileBuffer(boij, "image");
                const imageUrl = await uploadImageToTelegraph(owgi);
                reply(imageUrl);
              } else {
                reply('marque a ft')
              }
            } catch (e) {
              console.log(e)
              reply('error...')
            }
            break

          case 'videourl':
          case 'videopralink':
            try {
              if (isQuotedVideo) {
                boij = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage
                  : info.message.videoMessage;
                const fetch = require('node-fetch');
                const FormData = require('form-data');
                const fs = require('fs');
                async function uploadVideoToTelegraph(videoBuffer) {
                  const form = new FormData();
                  form.append('file', videoBuffer, { filename: 'media' });

                  const response = await fetch('https://telegra.ph/upload', {
                    method: 'POST',
                    body: form,
                  });
                  const data = await response.json();
                  if (data && data[0] && data[0].src) {
                    return 'https://telegra.ph' + data[0].src;
                  } else {
                    throw new Error('Failed to retrieve the image URL from the response.');
                  }
                }
                const owgi = await getFileBuffer(boij, "video");
                const imageUrl = await uploadVideoToTelegraph(owgi);
                reply(imageUrl);
              } else {
                reply('marque o video')
              }
            } catch (e) {
              console.log(e)
              reply('error...')
            }
            break



          case "recentes": {
            const fetch = require('node-fetch');

            async function recentes() {
              try {
                const response = await fetch('https://appp--trevodev.repl.co/recent-episodes?username=Clover&key=Clover');
                const data = await response.json();

                let resultInstance = '';

                data.forEach((anime) => {
                  resultInstance += `-------------------------------------\nAnime: ${anime.title}: ${anime.episodeNum}\n`;
                });

                console.log('ResultInstance:', resultInstance);
                return resultInstance;

              } catch (error) {
                console.error('Erro ao obter os animes recentes:', error);
                return 'Erro ao obter os animes recentes.';
              }
            }

            async function getRecentes() {
              const resultInstance = await recentes();
              const message = "ANIMES LAN√áAMENTOS\n\n" + resultInstance + "\n\n-------------------------------------";
              reply(message);
            }
            getRecentes();
          } break


          case 'totag':
          case 'cita':
          case 'hidetag':
            if (!isGroup) return reply('Este comando s√≥ deve ser utilizado em Grupo.')
            if (!isGroupAdmins) return reply('Voc√™ precisa ser ADM pra utilizar este comando')
            if (q.includes(`${prefix}`)) return reply("N√£o pode utilizar comandos nesse comando")
            if (q.includes("=>") || q.includes(">")) return
            membros = (groupId, membros1) => {
              array = []
              for (let i = 0; i < membros1.length; i++) {
                array.push(membros1[i].id)
              }
              return array
            }
            var yd = membros(from, groupMembers)
            if ((isMedia && !info.message.videoMessage || isQuotedSticker) && args.length == 0) {
              media = isQuotedSticker ? info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage : info.message.stickerMessage
              rane = getRandom('.' + await getExtension(media.mimetype))
              img = await getFileBuffer(media, 'sticker')
              fs.writeFileSync(rane, img)
              fig = fs.readFileSync(rane)
              var options = {
                sticker: fig,
                mentions: yd
              }
              client.sendMessage(from, options)
            } else if ((isMedia && !info.message.videoMessage || isQuotedImage) && args.length == 0) {
              media = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
              rane = getRandom('.' + await getExtension(media.mimetype))
              img = await getFileBuffer(media, 'image')
              fs.writeFileSync(rane, img)
              buff = fs.readFileSync(rane)
              client.sendMessage(from, { image: buff, mentions: yd }, { quoted: info })
            } else if ((isMedia && !info.message.videoMessage || isQuotedVideo) && args.length == 0) {
              media = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
              rane = getRandom('.' + await getExtension(media.mimetype))
              vid = await getFileBuffer(media, 'video')
              fs.writeFileSync(rane, vid)
              buff = fs.readFileSync(rane)
              client.sendMessage(from, { video: buff, mimetype: 'video/mp4', mentions: yd }, { quoted: info })
            } else if ((isMedia && !info.message.videoMessage || isQuotedAudio) && args.length == 0) {
              media = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
              rane = getRandom('.' + await getExtension(media.mimetype))
              aud = await getFileBuffer(media, 'audio')
              fs.writeFileSync(rane, aud)
              buff = fs.readFileSync(rane)
              client.sendMessage(from, { audio: buff, mimetype: 'audio/mp4', ptt: true, mentions: yd }, { quoted: info })
            } else if ((isMedia && !info.message.videoMessage || isQuotedDocument) && args.length == 0) {
              media = isQuotedDocument ? info.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage : info.message.documentMessage
              rane = getRandom('.' + await getExtension(media.mimetype))
              doc = await getFileBuffer(media, 'document')
              fs.writeFileSync(rane, doc)
              buff = fs.readFileSync(rane)
              client.sendMessage(from, { document: buff, mimetype: 'text/plain', mentions: yd }, { quoted: info })
            } else if (budy) {
              if (q.length < 1) return reply('Citar oq?')
              client.sendMessage(from, { text: body.slice(command.length + 2), mentions: yd })
            } else {
              reply(`Responder imagem/documento/gif/adesivo/√°udio/v√≠deo com legenda ${prefix + command}`)
            }
            break

          case 'antiimg':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            if (!isBotGroupAdmins) return reply(resposta.botadm)
            if (Number(args[0]) === 1) {
              if (isAntiImg) return reply('J√° Esta ativo')
              antiimg.push(from)
              fs.writeFileSync('./functions/antiimg.json', JSON.stringify(antiimg))
              reply('üçâativou com sucesso o recurso de anti imagem nesse grupoüçâ')
            } else if (Number(args[0]) === 0) {
              if (!isAntiImg) return reply('Ja esta Desativado.')
              antiimg.splice(from, 1)
              fs.writeFileSync('./functions/antiimg.json', JSON.stringify(antiimg))
              reply('üçâDesativou com sucesso o recurso de anti imagem nesse grupoüçâ')
            } else {
              if (isAntiImg) {
                buttons002 = [
                  { buttonId: `${prefix + command} 0`, buttonText: { displayText: '[üçâ] DESATIVAR [üçâ]' }, type: 1 }
                ]
              } else {
                buttons002 = [
                  { buttonId: `${prefix + command} 1`, buttonText: { displayText: '[üçâ] ATIVAR [üçâ]' }, type: 1 }
                ]
              }
              buttonMessage02 = {
                text: `‚ï≠‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïÆ   
    üëë ùêÄùêçùêìùêà ùêàùêåùêÄùêÜùêÑùêå üëë
    
    ùêîùêíùêî√Åùêëùêàùêé: ${pushname}
    
    ùêÜùêëùêîùêèùêé: ${groupName}
  ‚ï∞‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïØ`,
                footer: `STATUS DO ANTI-IMG AGORA:${isAntiImg ? 'ATIVADO' : 'DESATIVADO'}\n`,
                buttons: buttons002,
                headerType: 4,
                contextInfo: { forwardingScore: 999, isForwarded: true }
              }
              client.sendMessage(from, buttonMessage02, { quoted: info })
            }
            break



          case 'antilinkgp':
          case 'antilink':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            if (!isBotGroupAdmins) return reply(resposta.botadm)
            if (Number(args[0]) === 1) {
              if (isAntilinkgp) return reply('Ja esta ativo')
              antilinkgp.push(from)
              fs.writeFileSync('./functions/antilinkgp.json', JSON.stringify(antilinkgp))
              reply('üçâAtivou com sucesso o recurso de antilinkgpüçâ')
            } else if (Number(args[0]) === 0) {
              if (!isAntilinkgp) return reply('Ja esta Desativado')
              pesquisar = from
              processo = antilinkgp.indexOf(pesquisar)
              while (processo >= 0) {
                antilinkgp.splice(processo, 1)
                processo = antilinkgp.indexOf(pesquisar)
              }
              fs.writeFileSync('./functions/antilinkgp.json', JSON.stringify(antilinkgp))
              reply('üçâDesativou com sucesso o recurso de antilink de grupoüçâ')
            } else {
              if (isAntilinkgp) {
                buttons02 = [
                  { buttonId: `${prefix + command} 0`, buttonText: { displayText: '[üçâ] DESATIVAR [üçâ]' }, type: 1 }
                ]
              } else {
                buttons02 = [
                  { buttonId: `${prefix + command} 1`, buttonText: { displayText: '[üçâ] ATIVAR [üçâ]' }, type: 1 },
                ]
              }
              buttonMessage02 = {
                text: `‚ï≠‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïÆ   
    üëë ùêÄùêçùêìùêà ùêãùêàùêçùêä üëë
    
    ùêîùêíùêî√Åùêëùêàùêé: ${pushname}
    
    ùêÜùêëùêîùêèùêé: ${groupName}
  ‚ï∞‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïØ      `,
                footer: `STATUS DO ANTI-LINK AGORA: ${isAntilinkgp ? 'ATIVADO' : 'DESATIVADO'}\n`,
                buttons: buttons02,
                headerType: 4,
                contextInfo: { forwardingScore: 999, isForwarded: true }
              }
              client.sendMessage(from, buttonMessage02, { quoted: live })
            }
            break

          case 'nuke': case 'arquivargp':
            if (!isOwner) return reply(resposta.dono)
            if (!isBotGroupAdmins) return reply('Bot precisa ser ADM, para executar esta fun√ß√£o.')
            if (info.key.fromMe) return
            function banirtodos() {
              var r_banirtodos = Math.floor(Math.random() * groupMembers.length + 0)
              nmrbot = botNumber.split("@")[0]
              var resp = `${groupMembers[r_banirtodos].id.split("@")[0]}`
              if (resp === numeroDono || resp === nmrbot) {
                return
              } else {
                client.groupParticipantsUpdate(from, [resp + "@s.whatsapp.net"], 'remove')
              }
            }
            myinterval = setInterval(banirtodos, 1000)
            if (groupMembers.length <= 2) {
              clearInterval(myinterval);
            }
            break


          case "menulogos":
          case "logos":
            // client.sendMessage(from, { react: { text: `üçâ`, key: info.key }})
            //const buuttons = [
            ////  {buttonId: 'id', buttonText: {displayText: '[üëë]  [üëë]'}, type: 1},
            //{buttonId: `${prefix}ping`, buttonText: //{displayText: '[üèì] ùôãùôÑùôâùôÇ [üèì]'}, type: 1},
            //  {buttonId: `${prefix}infodono`, buttonText: //{displayText: '[üç∑] ùòøùôäùôâùôä [üç∑]'}, type: 1}
            //]

            const buuttonMessage = {
              image: { url: imagemdomenu },
              caption: `off`,
              footer: `  `,
              headerType: 4
            }

            client.sendMessage(from, buuttonMessage)


            break

          case "infodono":
          case "dono":
            const buttonMessage = {
              tetext: `‚ï≠‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚òÇÔ∏è‚ïê‚îÄ‚îÄ‚îÄ‚ïê‚ïÆ
      ‚ï†üçâ‚ûΩùóóùó¢ùó°ùó¢:Wa.me/${infoBot.numeroDono} 
      ‚ï∞‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïêüçâ‚ïê‚îÄ‚îÄ‚îÄ‚ïê‚ïØ
      ‚ï≠‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚òÇÔ∏è‚ïê‚îÄ‚îÄ‚îÄ‚ïê‚ïÆ
      ‚ï†üçâ‚ûΩùó£ùó•ùóòùóôùóúùó´:${prefix}
      ‚îÉ‚ú∞ 
      ‚ï†üçâ‚ûΩùóïùó¢ùóß:${nomeBot}
      ‚ï∞‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïêüçâ‚ïê‚îÄ‚îÄ‚îÄ‚ïê‚ïØ`,
              footer: `${nomeBot}`,
              headerType: 1
            }

            client.sendMessage(from, buttonMessage)
            break

          case 'grupoinfo':
          case 'infogrupo':
          case 'infogp':
          case 'gpinfo':
          case 'regras':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            ppUrl = await client.profilePictureUrl(from, 'image')
            const meetadata = await client.groupMetadata(from)
            client.sendMessage(from, { image: { url: ppUrl }, caption: `ùêçùêéùêåùêÑ : ${groupName}\nùêåùêÑùêåùêÅùêëùêéùêí : ${groupMembers.length}\nùêÄùêÉùêåùêí : ${groupAdmins.length}\nùêÉùêÑùêíùêÇùêëùêàùêÇùêÄùêé : ${meetadata.desc}`, thumbnail: null }, { quoted: info })
            break

          case 'status':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            statuszada = `‚ïî‚îÅ‚îÅ‚ù≤ ùêí ùêì ùêÄ ùêì ùêî ùêí ‚ù≥‚îÅ‚îÅ‚ïó 
      ‚îÉ Anti video = ${isAntiVid ? 'ON' : 'OFF'}
      ‚îÉ Anti img = ${isAntiImg ? 'ON' : 'OFF'}
      ‚îÉ Anti √°udios = ${isAntiAudio ? 'ON' : 'OFF'}
      ‚îÉ Anti sticker = ${isAntiSticker ? 'ON' : 'OFF'}
      ‚îÉ Anti pv block = ${isAntiPv ? 'ON' : 'OFF'}
      ‚îÉ Anti documentos = ${Antidoc ? 'ON' : 'OFF'}
      ‚îÉ Auto ban lista negra = ${islista ? 'ON' : 'OFF'}
      ‚îÉ Anti link grupo = ${isAntilinkgp ? 'ON' : 'OFF'}
      ‚îÉ Bem vindo = ${isWelkom ? 'ON' : 'OFF'}
      ‚ïö‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïù`
            client.sendMessage(from, { image: { url: logo }, caption: statuszada, thumbnail: null })
            break



          case "x4":
          case "4x4": {
            fras = [
              "Vamos com tudo, pessoal!",
              "Mostrem seu potencial agora!",
              "N√≥s somos impar√°veis!",
              "A vit√≥ria √© nossa, acreditem!",
              "A√ß√£o r√°pida, vit√≥ria certa!",
              "N√£o vamos deixar ningu√©m para tr√°s!",
              "Juntos, somos invenc√≠veis!",
              "Foco, determina√ß√£o e coragem!",
              "Nada pode nos deter!",
              "Vamos mostrar quem manda aqui!",
              "N√£o se esque√ßam de trabalhar em equipe!",
              "A sorte favorece os audaciosos!",
              "Vamos fazer hist√≥ria hoje!",
              "N√£o podemos desistir, a luta est√° s√≥ come√ßando!",
              "Concentra√ß√£o total, galera!",
              "N√£o tenham medo, enfrentem o perigo de frente!",
              "A vit√≥ria est√° a um passo de n√≥s, n√£o vamos recuar!",
              "Acreditem em si mesmos e ven√ßam!",
              "Vamos jogar com estrat√©gia e intelig√™ncia!",
              "Voc√™s s√£o os melhores, vamos mostrar isso agora!",
              "N√£o permitam que nos subestimem, mostrem do que somos capazes!",
              "Fiquem alertas, o inimigo est√° pr√≥ximo!",
              "A for√ßa est√° em cada um de n√≥s, vamos utiliz√°-la!",
              "N√£o deixem o cansa√ßo atrapalhar, sigam em frente!",
              "N√£o existe time melhor do que o nosso!"
            ]
            epa = fras[Math.floor(Math.random() * fras.length)]
            tabi = ["üòÄ", "üòÉ", "üòÅ", "üòÜ", "üòÇ", "ü§£", "üò≠", "üòâ", "üòò", "üòó", "ü•∞", "üòç", "ü§©", "ü•≥", "üôÉ", "üôÇ", "ü•≤", "üòã", "üòõ", "üòú", "üòù", "üòú", "üòá", "üòä", "‚ò∫Ô∏è", "üòè", "üòå", "üòî", "üòë", "üòê", "üò∂", "ü§î", "ü§´", "ü§≠", "ü•±", "ü§ó", "ü§®", "üßê", "üòí", "üôÑ", "üò§", "üò†", "ü§¨", "ü•∫", "üò•", "üòü", "‚òπÔ∏è", "üò¶", "üòß", "üò∞", "üò®", "üòï", "üòØ", "üò≤", "üò≥", "ü§Ø", "üò¨", "üòì", "üòì", "üòû", "üòñ", "ü•¥", "üòé", "ü§ì", "üòé", "ü•µ", "ü•∂", "üåû", "ü§•", "ü§°", "üòà", "ü•µ", "üëΩ", "üò∑", "üí¶", "üë∫", "üëπ", "üí®", "üò∏", "üòπ", "‚ù§Ô∏è", "ü´Ä", "üòª", "üíã", "ü´Ç", "üëÑ", "üëÖ", "üíÖ", "üôè", "ü§≥", "‚úçÔ∏è", "üôÖ", "üåÄ", "‚òÉÔ∏è", "üî•", "‚ö°", "üåà", "üíß", "üôà", "üçë", "üçí", "üçì", "üå∂Ô∏è", "üçÜ", "üç∑", "üç¥", "üçΩÔ∏è", "üõ¢Ô∏è", "üö®", "üé§", "üé≠", "üìΩÔ∏è", "üé∞", "‚òéÔ∏è", "üìû", "üëë", "üíé", "üíç", "üó°Ô∏è", "‚öîÔ∏è", "üí£", "‚ÅâÔ∏è", "‚úÖ", "‚ô•Ô∏è", "üß°", "üíõ", "üíö", "üíô", "üíú", "ü§é", "üñ§", "ü§ç", "üáßüá∑", "üè≥Ô∏è‚Äçüåà", "ü§î", "ü§´", "üòè", "üçÜ", "üë∫", "üôä"]
            kkk = tabi[Math.floor(Math.random() * tabi.length)]

            membros = (groupId, membros1) => {
              array = []
              for (let i = 0; i < membros1.length; i++) {
                array.push(membros1[i].id)
              }
              return array
            }
            var yd = membros(from, groupMembers)

            client.sendMessage(from, {
              text: `${groupName}
  
  ‚öîÔ∏èSLOT 1‚öîÔ∏è
  ${kkk}
  ${kkk}
  ${kkk}
  ${kkk}
  
  ‚öîÔ∏èSLOT 2‚öîÔ∏è
  ${kkk}
  ${kkk}
  ${kkk}
  ${kkk}
  
  ${epa}`,
              mentions: yd
            })

          } break

          case "x6":
          case "6x6": {

            fras = [
              "Vamos com tudo, pessoal!",
              "Mostrem seu potencial agora!",
              "N√≥s somos impar√°veis!",
              "A vit√≥ria √© nossa, acreditem!",
              "A√ß√£o r√°pida, vit√≥ria certa!",
              "N√£o vamos deixar ningu√©m para tr√°s!",
              "Juntos, somos invenc√≠veis!",
              "Foco, determina√ß√£o e coragem!",
              "Nada pode nos deter!",
              "Vamos mostrar quem manda aqui!",
              "N√£o se esque√ßam de trabalhar em equipe!",
              "A sorte favorece os audaciosos!",
              "Vamos fazer hist√≥ria hoje!",
              "N√£o podemos desistir, a luta est√° s√≥ come√ßando!",
              "Concentra√ß√£o total, galera!",
              "N√£o tenham medo, enfrentem o perigo de frente!",
              "A vit√≥ria est√° a um passo de n√≥s, n√£o vamos recuar!",
              "Acreditem em si mesmos e ven√ßam!",
              "Vamos jogar com estrat√©gia e intelig√™ncia!",
              "Voc√™s s√£o os melhores, vamos mostrar isso agora!",
              "N√£o permitam que nos subestimem, mostrem do que somos capazes!",
              "Fiquem alertas, o inimigo est√° pr√≥ximo!",
              "A for√ßa est√° em cada um de n√≥s, vamos utiliz√°-la!",
              "N√£o deixem o cansa√ßo atrapalhar, sigam em frente!",
              "N√£o existe time melhor do que o nosso!"
            ]
            epa = fras[Math.floor(Math.random() * fras.length)]

            tabi = ["üòÄ", "üòÉ", "üòÅ", "üòÜ", "üòÇ", "ü§£", "üò≠", "üòâ", "üòò", "üòó", "ü•∞", "üòç", "ü§©", "ü•≥", "üôÉ", "üôÇ", "ü•≤", "üòã", "üòõ", "üòú", "üòù", "üòú", "üòá", "üòä", "‚ò∫Ô∏è", "üòè", "üòå", "üòî", "üòë", "üòê", "üò∂", "ü§î", "ü§´", "ü§≠", "ü•±", "ü§ó", "ü§®", "üßê", "üòí", "üôÑ", "üò§", "üò†", "ü§¨", "ü•∫", "üò•", "üòü", "‚òπÔ∏è", "üò¶", "üòß", "üò∞", "üò®", "üòï", "üòØ", "üò≤", "üò≥", "ü§Ø", "üò¨", "üòì", "üòì", "üòû", "üòñ", "ü•¥", "üòé", "ü§ì", "üòé", "ü•µ", "ü•∂", "üåû", "ü§•", "ü§°", "üòà", "ü•µ", "üëΩ", "üò∑", "üí¶", "üë∫", "üëπ", "üí®", "üò∏", "üòπ", "‚ù§Ô∏è", "ü´Ä", "üòª", "üíã", "ü´Ç", "üëÑ", "üëÖ", "üíÖ", "üôè", "ü§≥", "‚úçÔ∏è", "üôÖ", "üåÄ", "‚òÉÔ∏è", "üî•", "‚ö°", "üåà", "üíß", "üôà", "üçë", "üçí", "üçì", "üå∂Ô∏è", "üçÜ", "üç∑", "üç¥", "üçΩÔ∏è", "üõ¢Ô∏è", "üö®", "üé§", "üé≠", "üìΩÔ∏è", "üé∞", "‚òéÔ∏è", "üìû", "üëë", "üíé", "üíç", "üó°Ô∏è", "‚öîÔ∏è", "üí£", "‚ÅâÔ∏è", "‚úÖ", "‚ô•Ô∏è", "üß°", "üíõ", "üíö", "üíô", "üíú", "ü§é", "üñ§", "ü§ç", "üáßüá∑", "üè≥Ô∏è‚Äçüåà", "ü§î", "ü§´", "üòè", "üçÜ", "üë∫", "üôä"]
            kkk = tabi[Math.floor(Math.random() * tabi.length)]
            membros = (groupId, membros1) => {
              array = []
              for (let i = 0; i < membros1.length; i++) {
                array.push(membros1[i].id)
              }
              return array
            }
            var yd = membros(from, groupMembers)

            client.sendMessage(from, {
              text: `${groupName}
  
  ‚öîÔ∏èSLOT 1‚öîÔ∏è
  ${kkk}
  ${kkk}
  ${kkk}
  ${kkk}
  ${kkk}
  ${kkk}
  
  ‚öîÔ∏èSLOT 2‚öîÔ∏è
  ${kkk}
  ${kkk}
  ${kkk}
  ${kkk}
  ${kkk}
  ${kkk}
  
  
  ${epa}`,
              mentions: yd
            })

          } break





          case 'bemvindo':
            if (!isGroup) return reply("so em grupo")
            if (!isGroupAdmins) return reply("so pros admin")
            if (!isBotGroupAdmins) return reply("bot nao e adm para usar")
            if (Number(args[0]) === 1) {
              if (isWelkom) return reply('Ja esta ativo')
              welkom.push(from)
              fs.writeFileSync('./functions/welkom.json', JSON.stringify(welkom))
              reply(' Ativou com sucesso o recurso de bem vindo neste grupo üìù')
            } else if (Number(args[0]) === 0) {
              if (!isWelkom) return reply('Ja esta Desativado')
              pesquisar = from
              processo = welkom.indexOf(pesquisar)
              while (processo >= 0) {
                welkom.splice(processo, 1)
                processo = welkom.indexOf(pesquisar)
              }
              fs.writeFileSync('./functions/welkom.json', JSON.stringify(welkom))
              reply('‚ÄºÔ∏è Desativou com sucesso o recurso de bemvindo neste grupo‚úîÔ∏è')
            } else {
              reply("1 para ativar, 0 para desativar")
            }
            break

          case 'autoban':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            if (args.length < 1) return reply('ü•ãautoban 1 pra ativar,e autoban 0 pra desativar ü•ã')
            if (Number(args[0]) === 1) {
              if (islista) return reply("ü•ãJ√° est√° ativadoü•ã")
              var ind = dbids.indexOf(from)
              if (islista) {
                lista[ind].actived = true
              } else {
                lista.push({
                  groupId: from,
                  actived: true,
                  number: []
                })
              }
              fs.writeFileSync('./functions/lista.json', JSON.stringify(lista, null, 2) + '\n')
              reply(`üçâAtivou com sucesso o recurso de autoban neste grupoüçâ`)
            } else if (Number(args[0]) === 0) {
              if (!islista) return reply("ü•ãJ√° est√° Desativado.ü•ã")
              var ind = dbids.indexOf(from)
              if (islista) {
                lista[ind].actived = false
              } else {
                lista.push({
                  groupId: from,
                  actived: false,
                  number: []
                })
              }
              fs.writeFileSync('./functions/lista.json', JSON.stringify(lista, null, 2) + '\n')
              reply(`üçâDesativou com sucesso o recurso de autoban neste grupoüçâ`)
            } else {
              reply('1 para ativar, 0 para desativar')
            }
            break


          case 'listban':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            var ind = dbids.indexOf(from)
            if (!islista) return reply('Nenhum N√∫mero n√£o foi adicionado')
            teks = 'üçâN√∫meros que vou moer na porrada se voltar üò°\n'
            for (i = 0; i < lista[ind].number.length; ++i) {
              teks += `‚û§ *${lista[ind].number[i]}*\n`
            }
            teks += '*Esses ai vou descer meu martelo do ban ü•µ*'
            reply(teks)
            break


          case 'addlistanegra':
          case 'addlista':
            if (!isGroupAdmins) return reply(resposta.adm)
            if (args.length < 1) return reply('Cade o n√∫mero?')
            var ind = dbids.indexOf(from)
            if (islista) {
              listng = q.replace(new RegExp("[()+-/ +/]", "gi"), "")
              var numind = lista[ind].number.indexOf(listng)
              if (numind >= 0) return reply('üçâeste N√∫mero ja esta inclusoüçâ')
              lista[ind].number.push(listng)
            } else {
              listng = q.replace(new RegExp("[()+-/ +/]", "gi"), "")
              lista.push({
                groupId: from,
                actived: false,
                number: [listng]
              })
            }
            fs.writeFileSync('./functions/lista.json', JSON.stringify(lista, null, 2) + '\n')
            reply(`üçâN√∫mero adicionado a lista de autoban com sucesso üçâ`)
            break

          case 'dellistanegra':
          case 'dellista':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            if (args.length < 1) return reply('üçâDiga o numero sem espa√ßo, + ou tra√ßoüçâ')
            if (isNaN(args[0])) return reply('üçâDiga o numero sem espa√ßo, + ou tra√ßoüçâ')
            var ind = dbids.indexOf(from)
            if (!islista) return reply('Nenhum N√∫mero n√£o foi adicionado')
            var numind = lista[ind].number.indexOf(args[0])
            if (numind < 0) return reply('üçâEsse n√∫mero n√£o est√° incluso na lista de autobanüòë')
            lista[ind].number.splice(numind, 1)
            fs.writeFileSync('./functions/lista.json', JSON.stringify(lista, null, 2) + '\n')
            reply(`üçâN√∫mero removido a lista de autoban com sucesso üçâ`)
            break

          case 'linkgp':
          case 'linkgroup':
            if (!isGroupAdmins) return reply(resposta.adm)
            if (!isGroup) return reply(resposta.grupo)
            if (!isBotGroupAdmins) return reply(resposta.botadm)
            let metadata = await client.groupMetadata(from)
            linkgc = await client.groupInviteCode(from)
            reply(` ${metadata.participants.length ? metadata.participants.length : "undefined"} PARTICIPANTES DO GRUPOüçâ  üçâLINK DO GRUPOüçâ           ${groupMetadata.subject}üçâhttps://chat.whatsapp.com/` + linkgc)
            break

          case 'promover':
          case 'promote':
            if (!isGroupAdmins) return reply('üçâS√≥ ADM pode utilizar este comandoüçâ')
            if (!isBotGroupAdmins) return reply('üçâO Bot Precisa ser ADM pra executar esse comandoüçâ.')

            if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('üçâMarque ou responda a mensagem de quem voc√™ quer promoverüçâ')
            mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid[0] ? info.message.extendedTextMessage.contextInfo.mentionedJid[0] : info.message.extendedTextMessage.contextInfo.participant
            if (botNumber.includes(mentioned)) return reply("üòë")

            let responsedm = await client.groupParticipantsUpdate(from, [mentioned], 'promote')
            if (responsedm[0].status === "200") client.sendMessage(from, { text: `@${mentioned.split("@")[0]} üòÇagora √© um fiscal do barüòÇ.Ô∏è`, mentions: [mentioned, sender], contextInfo: { forwardingScore: 999, isForwarded: true } })
            else if (responsedm[0].status === "404") client.sendMessage(from, { text: `@${mentioned.split("@")[0]} n√£o est√° no grupoÔ∏è`, mentions: [mentioned, sender], contextInfo: { forwardingScore: 999, isForwarded: true } })
            else client.sendMessage(from, { text: `üò•Parece que deu erroüò•Ô∏è`, mentions: [sender], contextInfo: { forwardingScore: 999, isForwarded: true } })
            break

          case "rebaixar":
            if (!isGroupAdmins) return reply(resposta.adm);
            if (!isBotGroupAdmins) return reply(resposta.botadm);
            if (
              info.message.extendedTextMessage === undefined ||
              info.message.extendedTextMessage === null
            )
              return reply(
                "üçâMarque ou responda a mensagem de quem voc√™ quer tirar o adminüçâ"
              );
            mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid[0]
              ? info.message.extendedTextMessage.contextInfo.mentionedJid[0]
              : info.message.extendedTextMessage.contextInfo.participant;
            if (botNumber.includes(mentioned))
              return reply("üòë marque outra pessoa");
            let responsepm = await client.groupParticipantsUpdate(
              from,
              [mentioned],
              "demote"
            );
            if (responsepm[0].status === "406")
              client.sendMessage(from, {
                text: `@${mentioned.split("@")[0]
                  } criou esse grupo e n√£o pode ser removido(a) da lista de admins.Ô∏è`,
                mentions: [mentioned, sender],
                contextInfo: { forwardingScore: 999, isForwarded: true },
              });
            else if (responsepm[0].status === "200")
              client.sendMessage(from, {
                text: `@${mentioned.split("@")[0]} üò•n√£o e mais adm do grupoüò•`,
                mentions: [mentioned, sender],
                contextInfo: { forwardingScore: 999, isForwarded: true },
              });
            else if (responsepm[0].status === "404")
              client.sendMessage(from, {
                text: `@${mentioned.split("@")[0]} n√£o est√° no grupoüòëÔ∏è`,
                mentions: [mentioned, sender],
                contextInfo: { forwardingScore: 999, isForwarded: true },
              });
            else
              client.sendMessage(from, {
                text: `Parece que deu erroÔ∏è`,
                mentions: [sender],
                contextInfo: { forwardingScore: 999, isForwarded: true },
              });
            break;


          case 'reviver':
          case 'add':
            if (!isGroup) return reply('üçâCOMANDO SO PARA GRUPOüçâ')
            if (!isOwner) return reply(resposta.dono)
            if (!isGroupAdmins) return reply('üòÇCOMANDO SO PARA ADMüòÇ')
            if (!isBotGroupAdmins) return reply("üçâBOT PRECISA SER ADMüçâ")
            if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('üçâMARQUE A MENSAGEM DO USU√ÅRIO PRA MIM ADICIONAüçâ')
            response2 = await client.groupParticipantsUpdate(from, [menc_prt], "add")
            reply('üçâUSU√ÅRIO ADICIONADO COM SUCESSO üçâ')
            break

          case 'sairgp':
            if (isGroup && !isOwner && !info.key.fromMe) return reply("üçâCOMANDO SO PARA DONOüçâ")
            try {
              client.groupLeave(from)
            } catch (erro) {
              reply(String(erro))
            }
            break

          case 'abrirgp':
          case 'fechagp':
          case 'grupo':
            if (!isGroup) return reply(`S√ì EM GRUPO`)
            if (!isGroupAdmins) return reply(`PRECISA SER ADMININASTROR`)
            if (!isBotGroupAdmins) return reply(`BOT PREPRECISA SER ADMININASTROR`)
            if (args[0] === 'a') {
              reply(`*GRUPO ABERTO COM SUCESSO*`)
              await client.groupSettingUpdate(from, 'not_announcement')
            } else if (args[0] === 'f') {
              reply(`*GRUPO FECHADO COM SUCESSO*`)
              await client.groupSettingUpdate(from, 'announcement')
            }
            break

          case 'novolink':
          case 'redefinir':
            if (!isGroupAdmins) return reply(resposta.adm)
            if (!isGroup) return reply(resposta.grupo)
            if (!isBotGroupAdmins) return reply(resposta.botadm)
            try {
              await client.groupRevokeInvite(from)
              reply('üçâLINK DO GRUPO REDEFINIDOüçâ')
            } catch (e) {
              console.log(e)
              reply(`ERRO`)
            }
            break

          case 'setfotogp':
          case 'fotogp':
            addFilter(from)
            if (!isGroup) return reply('üçâESTE COMANDO SO PODE SER UTILIZANDO EM GRUPOüçâ')
            if (!isGroupAdmins) return reply('üçâCOMANDO SO PARA ADMüçâ')
            if (!isBotGroupAdmins) return reply('üçâO BOT PRECISA SER ADMüçâ')
            if (!isQuotedImage) return reply(`Use: ${prefix + command} Marque uma foto`)
            ftgp = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
            rane = getRandom('.' + await getExtension(ftgp.mimetype))
            buffimg = await getFileBuffer(ftgp, 'image')
            fs.writeFileSync(rane, buffimg)
            medipp = rane
            await client.updateProfilePicture(from, { url: medipp })
            reply(`üçâFOTO DO GRUPO ALTERADA COM SUCESSOüçâ`)
            break

          case 'nomegp':
            {
              if (!isGroup) return reply(resposta.grupo)
              if (!isGroupAdmins) return reply(resposta.adm)
              if (!isBotGroupAdmins) return reply(resposta.botadm)
              blat = args.join(" ")
              client.groupUpdateSubject(from, `${blat}`)
              client.sendMessage(from, { text: 'üçâNOME DO GRUPO ALTERADO COM SUCESSO üçâ' }, { quoted: info }).catch((err) => {
                reply(`erro`);
              })
            }
            break

          case 'descgp':
          case 'descri√ß√£ogp':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            if (!isBotGroupAdmins) return reply(resposta.botadm)
            blabla = args.join(" ")
            client.groupUpdateDescription(from, `${blabla}`)
            client.sendMessage(from, { text: 'Sucesso, alterou a descri√ß√£o do grupo' }, { quoted: info })
            break


          case 'setfotogp':
          case 'fotogp':
            addFilter(from)
            if (!isGroup) return reply('S√≥ pode ser utilizado em Grupo')
            if (!isGroupAdmins) return reply('Voc√™ precisa ser ADM')
            if (!isBotGroupAdmins) return reply('O bot Precisa ser ADM')
            if (!isQuotedImage) return reply(`Use: ${prefix + command} <Marque uma foto>`)
            ftgp = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
            rane = getRandom('.' + await getExtension(ftgp.mimetype))
            buffimg = await getFileBuffer(ftgp, 'image')
            fs.writeFileSync(rane, buffimg)
            medipp = rane
            await client.updateProfilePicture(from, { url: medipp })
            reply(`Foto do grupo alterada com sucesso`)
            break

          case 'fotobot':
            if (!isOwner) return reply(resposta.dono)
            if (!isQuotedImage) return reply(`Envie fotos com legendas ${prefix}fotobot ou tags de imagem que j√° foram enviadas`)
            buff = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage, 'image')
            await client.updateProfilePicture(botNumber, buff)
            reply('Obrigado pelo novo perfil vlw')
            break


          case 'autofig-gp':
          case 'autofig':
            if (!isGroup) return reply(resposta.grupo);
            if (!isGroupAdmins) return reply(resposta.adm);
            if (!isBotGroupAdmins) return reply(resposta.botadm);
            if (Number(args[0]) === 1) {
              if (isAutoSticker) return reply('J√° est√° ativo');
              autosticker.push(from);
              fs.writeFileSync('./functions/autosticker.json', JSON.stringify(autosticker));
              reply('üçâ Ativou com sucesso o recurso de auto fig üçâ');
            } else if (Number(args[0]) === 0) {
              if (!isAutoSticker) return reply('J√° est√° desativado');
              pesquisar = from;
              processo = autosticker.indexOf(pesquisar);
              while (processo >= 0) {
                autosticker.splice(processo, 1);
                processo = autosticker.indexOf(pesquisar);
              }
              fs.writeFileSync('./functions/autosticker.json', JSON.stringify(autosticker));
              reply('üçâ Desativou com sucesso o recurso de auto fig de grupo üçâ');
            }
            break;


          case 'autorea√ß√£o':
          case 'autoreacao':
          case 'autoreact':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            if (Number(args[0]) === 1) {
              if (isAutoReact) return reply('J√° est√° ativado')
              autoreact.push(from)
              fs.writeFileSync('./functions/autoreact.json', JSON.stringify(autoreact))
              reply('[üçâ] Ativou com sucesso o recurso de auto rea√ß√£o neste grupo [üçâ]')
            } else if (Number(args[0]) === 0) {
              if (!isAutoReact) return reply('J√° est√° desativado')
              pesquisar = from
              processo = autoreact.indexOf(pesquisar)
              while (processo >= 0) {
                autoreact.splice(processo, 1)
                processo = autoreact.indexOf(pesquisar)
              }
              fs.writeFileSync('./functions/autoreact.json', JSON.stringify(autoreact))
              reply('üçâDesativou com sucesso o recurso de auto rea√ß√£o nesse grupoüçâ')
            } else {
              if (isAutoReact) {
                buttons02 = [{ buttonId: `${prefix + command} 0`, buttonText: { displayText: '[üçâ] DESATIVAR[üçâ]' }, type: 1 }]
              } else {
                buttons02 = [{ buttonId: `${prefix + command} 1`, buttonText: { displayText: '[üçâ] ATIVAR [üçâ]' }, type: 1 }]
              }
              buttonMessage02 = {
                text: `‚ï≠‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïÆ   
    üëë ùêÄùêîùêìùêé ùêëùêÑùêÄ√á√Éùêé üëë
    
    ùêîùêíùêî√Åùêëùêàùêé: ${pushname}
    
    ùêÜùêëùêîùêèùêé: ${groupName}
  ‚ï∞‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïØ`,
                footer: `STATUS DO AUTO-REACT AGORA ${isAutoReact ? 'ATIVADO' : 'DESATIVADO'}\n`,
                //buttons: buttons02,
                headerType: 4,
                contextInfo: { forwardingScore: 999, isForwarded: true }
              }
              client.sendMessage(from, buttonMessage02, { quoted: info })
            }
            break

          case 'antisticker':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            if (!isBotGroupAdmins) return reply(resposta.botadm)
            if (Number(args[0]) === 1) {
              if (isAntiSticker) return reply('J√° Esta ativo')
              antisticker.push(from)
              fs.writeFileSync('./functions/antisticker.json', JSON.stringify(antisticker))
              reply('üçâAtivou com sucesso o recurso de anti-sticker nesse grupoüçâ')
            } else if (Number(args[0]) === 0) {
              if (!isAntiSticker) return reply('Ja esta Desativado.')
              antisticker.splice(from, 1)
              fs.writeFileSync('./functions/antisticker.json', JSON.stringify(antisticker))
              reply('üçâDesativou com sucesso o recurso de anti-sticker nesse grupo üçâ')
            } else {
              if (isAntiSticker) {
                buttons02 = [
                  { buttonId: `${prefix + command} 0`, buttonText: { displayText: '[üçâ] DESATIVAR [üçâ]' }, type: 1 }
                ]
              } else {
                buttons02 = [
                  { buttonId: `${prefix + command} 1`, buttonText: { displayText: '[üçâ] ATIVAR [üçâ]' }, type: 1 }
                ]
              }
              buttonMessage02 = {
                text: `‚ï≠‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïÆ   
    üëë ùêÄùêçùêìùêà STICKER üëë
    
    ùêîùêíùêî√Åùêëùêàùêé: ${pushname}
    
    ùêÜùêëùêîùêèùêé: ${groupName}
  ‚ï∞‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïØ
  `,
                footer: `STATUS DO ANTI-STICKER AGORA:${isAntiSticker ? 'ATIVADO' : 'DESATIVAR'}\n`,
                //buttons: buttons02,
                headerType: 4,
                contextInfo: { forwardingScore: 999, isForwarded: true }
              }
              client.sendMessage(from, buttonMessage02, { quoted: info })
            }
            break

          case 'leave':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            if (!isBotGroupAdmins) return reply(resposta.botadm)
            const leaveMessage = {
              text: `O bot saiu do grupo: ${groupName}`,
              footer: `${nomeBot}`,
              headerType: 1
            }

            client.sendMessage(from, leaveMessage)
            client.leaveGroup(groupId)
            break

          case 'mute':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            if (!isBotGroupAdmins) return reply(resposta.botadm)
            const muteMessage = {
              text: `O bot silenciou o grupo: ${groupName}`,
              footer: `${nomeBot}`,
              headerType: 1
            }

            client.sendMessage(from, muteMessage)
            client.groupSettingChange(groupId, GroupSettingChange.messageSend, false)
            break

          case 'unmute':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            if (!isBotGroupAdmins) return reply(resposta.botadm)
            const unmuteMessage = {
              text: `O bot destilenciou o grupo: ${groupName}`,
              footer: `${nomeBot}`,
              headerType: 1
            }

            client.sendMessage(from, unmuteMessage)
            client.groupSettingChange(groupId, GroupSettingChange.messageSend, true)
            break
          case 'antiimg':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            if (!isBotGroupAdmins) return reply(resposta.botadm)
            if (Number(args[0]) === 1) {
              if (isAntiImg) return reply('J√° Esta ativo')
              antiimg.push(from)
              fs.writeFileSync('./functions/antiimg.json', JSON.stringify(antiimg))
              reply('üçâativou com sucesso o recurso de anti imagem nesse grupoüçâ')
            } else if (Number(args[0]) === 0) {
              if (!isAntiImg) return reply('Ja esta Desativado.')
              antiimg.splice(from, 1)
              fs.writeFileSync('./functions/antiimg.json', JSON.stringify(antiimg))
              reply('üçâDesativou com sucesso o recurso de anti imagem nesse grupoüçâ')
            } else {
              if (isAntiImg) {
                buttons002 = [
                  { buttonId: `${prefix + command} 0`, buttonText: { displayText: '[üçâ] DESATIVAR [üçâ]' }, type: 1 }
                ]
              } else {
                buttons002 = [
                  { buttonId: `${prefix + command} 1`, buttonText: { displayText: '[üçâ] ATIVAR [üçâ]' }, type: 1 }
                ]
              }
              buttonMessage02 = {
                text: `‚ï≠‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïÆ   
    üëë ùêÄùêçùêìùêà ùêàùêåùêÄùêÜùêÑùêå üëë
    
    ùêîùêíùêî√Åùêëùêàùêé: ${pushname}
    
    ùêÜùêëùêîùêèùêé: ${groupName}
  ‚ï∞‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïØ`,
                footer: `STATUS DO ANTI-IMG AGORA:${isAntiImg ? 'ATIVADO' : 'DESATIVADO'}\n`,
                //buttons: buttons002,
                headerType: 4,
                contextInfo: { forwardingScore: 999, isForwarded: true }
              }
              client.sendMessage(from, buttonMessage02, { quoted: info })
            }
            break

          case "gp":
          case "msgdiretagp": {
            texto = args.join(' ')
            texto1 = texto.split('/')[0] || 'Indefinido'
            texto2 = texto.split('/')[1] || 'Indefinido'
            if (!isOwner) return
            if (!texto.includes("/")) return reply(`Digite o texto que vai aparecer Exemplo: /msgdireta iddogp/TXT
  tem que ter a / e o id do grupo destinado sen√£o n√£o vai.`)
            let buttonMessage = {
              image: { url: imagemdomenu },
              caption: (`${texto2}`),
              footer: ` `,
              headerType: 4
            }
            client.sendMessage(`${texto1}@g.us`, buttonMessage)
          }
            break

          case 'tagall':
          case 'marcar': {
            if (!isGroup) return reply(resposta.group)
            if (!isGroupAdmins) return reply(resposta.adm)
            let metadata = await client.groupMetadata(from)
            let teks = `
  \n ${metadata.participants.length ? metadata.participants.length : "undefined"} participantes do grupo
  \n ${args.join(" ") ? args.join(" ") : 'kosong'}*\n\n`
            for (let mem of participants) {
              teks += `‚îÉ‚ùñ‚îÉ@${mem.id.split('@')[0]}\n`
            }
            client.sendMessage(from, { text: teks, mentions: participants.map(a => a.id) }, { quoted: live })
          }
            break

          case 'antivideo':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            if (!isBotGroupAdmins) return reply(resposta.botadm)
            if (Number(args[0]) === 1) {
              if (isAntiVid) return reply('Ja esta ativoü§ù')
              antivid.push(from)
              fs.writeFileSync('./functions/antivideo.json', JSON.stringify(antivid))
              reply('üçâAtivou com sucesso o recurso de anti video neste grupo‚úîüçâ')
            } else if (Number(args[0]) === 0) {
              if (!isAntiVid) return reply('Ja esta Desativado')
              antivid.splice(from, 1)
              fs.writeFileSync('./functions/antivideo.json', JSON.stringify(antivid))
              reply('üçâDesativou com sucesso o recurso de anti video neste grupoüçâ')
            } else {
              if (isAntiVid) {
                buttons02 = [
                  { buttonId: `${prefix + command} 0`, buttonText: { displayText: '[üçâ] DESATIVAR [üçâ]' }, type: 1 }
                ]
              } else {
                buttons02 = [
                  { buttonId: `${prefix + command} 1`, buttonText: { displayText: '[üçâ] ATIVAR [üçâ]' }, type: 1 }
                ]
              }
              buttonMessage02 = {
                text: `‚ï≠‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïÆ   
    üëë ùêÄùêçùêìùêà ùêïùêàùêÉùêÑùêé üëë
    
    ùêîùêíùêî√Åùêëùêàùêé: ${pushname}
    
    ùêÜùêëùêîùêèùêé: ${groupName}
  ‚ï∞‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïØ `,
                footer: `STATUS DO ANTIVIDEO AGORA: ${isAntiVid ? 'ATIVADO' : 'DESATIVADO'}\n`,
                //buttons: buttons02,
                headerType: 4,
                contextInfo: { forwardingScore: 999, isForwarded: true }
              }
              client.sendMessage(from, buttonMessage02, { quoted: info })
            }
            break

          case 'antiaudio':
            if (!isGroup) return reply(respostagrupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            if (!isBotGroupAdmins) return reply(resposta.botadm)
            if (Number(args[0]) === 1) {
              if (isAntiAudio) return reply('ü§ùJa esta ativoü§ù')
              antiaudio.push(from)
              fs.writeFileSync('./functions/antiaudio.json', JSON.stringify(antiaudio))
              reply('üçâAtivou com sucesso o recurso de anti audio neste grupoüçâ')
            } else if (Number(args[0]) === 0) {
              if (!isAntiAudio) return reply('ü§ùJa esta Desativadoü§ù')
              antiaudio.splice(from, 1)
              fs.writeFileSync('./functions/antiaudio.json', JSON.stringify(antiaudio))
              reply('üçâDesativou com sucesso o recurso de anti audio neste grupoüçâ')
            } else {
              if (isAntiAudio) {
                buttons02 = [
                  { buttonId: `${prefix + command} 0`, buttonText: { displayText: '[üçâ] DESATIVAR [üçâ]' }, type: 1 }
                ]
              } else {
                buttons02 = [
                  { buttonId: `${prefix + command} 1`, buttonText: { displayText: '[üçâ] ATIVAR [üçâ]' }, type: 1 }
                ]
              }
              buttonMessage02 = {
                text: `‚ï≠‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïÆ   
    üëë ùêÄùêçùêìùêà ùêÄùêîùêÉùêàùêéüëë
    
    ùêîùêíùêî√Åùêëùêàùêé: ${pushname}
    
    ùêÜùêëùêîùêèùêé: ${groupName}
  ‚ï∞‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïØ
  `,
                footer: `STATUS DO ANTI-AUDIO: AGORA ${isAntiAudio ? 'ATIVADO' : 'DESATIVADO'}\n`,
                //buttons: buttons02,
                headerType: 4,
                contextInfo: { forwardingScore: 999, isForwarded: true }
              }
              client.sendMessage(from, buttonMessage02, { quoted: info })
            }
            break

          case 'antidocumento':
          case 'antidoc':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            if (!isBotGroupAdmins) return reply(resposta.botadm)
            if (Number(args[0]) === 1) {
              if (Antidoc) return reply('üçâJa esta ativoüçâ')
              antidoc.push(from)
              fs.writeFileSync('./functions/antidoc.json', JSON.stringify(antidoc))
              reply('üçâAtivou com sucesso o recurso de anti documento neste grupo üçâ')
            } else if (Number(args[0]) === 0) {
              if (!Antidoc) return reply('üçâJa esta Desativadoüçâ')
              pesquisar = from
              processo = antidoc.indexOf(pesquisar)
              while (processo >= 0) {
                antidoc.splice(processo, 1)
                processo = antidoc.indexOf(pesquisar)
              }
              fs.writeFileSync('./functions/antidoc.json', JSON.stringify(antidoc))
              reply('üçâDesativou com sucesso o recurso de anti documento neste grupoüçâ')
            } else {
              if (Antidoc) {
                buttons02 = [
                  { buttonId: `${prefix + command} 0`, buttonText: { displayText: '[üçâ] DESATIVAR [üçâ]' }, type: 1 }
                ]
              } else {
                buttons02 = [
                  { buttonId: `${prefix + command} 1`, buttonText: { displayText: '[üçâ] ATIVAR [üçâ]' }, type: 1 }
                ]
              }
              buttonMessage02 = {
                text: `‚ï≠‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïÆ   
    üëë ùêÄùêçùêìùêà ùêÉùêéùêÇùêîùêåùêÑùêçùêìùêé üëë
    
    ùêîùêíùêî√Åùêëùêàùêé: ${pushname}
    
    
    ùêÜùêëùêîùêèùêé: ${groupName}
  ‚ï∞‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚åò‚ïê‚îÄ‚îÄ‚îÄ‚îÄ‚ïê‚ïØ      
  `,
                footer: `STATUS DO ANTIDOC AGORA:${Antidoc ? 'ATIVADO' : 'DESATIVADO'}\n`,
                //buttons: buttons02,
                headerType: 4,
                contextInfo: { forwardingScore: 999, isForwarded: true }
              }
              client.sendMessage(from, buttonMessage02, { quoted: info })
            }
            break

          case 'antipv':
            if (!isOwner) return reply(`Apenas dono pode ativar/desativar essa fun√ß√£o..`)
            if (args.length < 1) return reply('1 pra ligar / 0 pra desligar')
            if (Number(args[0]) === 1) {
              if (isAntiPv) return reply('Ja esta ativo')
              antipv.push('Ativado')
              fs.writeFileSync('./functions/antipv.json', JSON.stringify(antipv))
              reply('üåÄ Ativou com sucesso o recurso de Anti Privado üìù')
            } else if (Number(args[0]) === 0) {
              if (!isAntiPv) return reply('Ja esta Desativado')
              pesquisar = 'Ativado'
              processo = antipv.indexOf(pesquisar)
              while (processo >= 0) {
                antipv.splice(processo, 1)
                processo = antipv.indexOf(pesquisar)
              }
              fs.writeFileSync('./functions/antipv.json', JSON.stringify(welkom))
              reply('‚ÄºÔ∏è Desativou com sucesso o recurso De ANTIPV‚úîÔ∏è')
            } else {
              enviar('1 para ativar, 0 para desativar')
            }
            break

          case 'fstiker':
          case 'fsticker':
          case 'f':
          case 's':
          case 'stickergif':
          case "sticker":
          case 'sgif':
          case 'figu':
          case 'st':
          case 'stk':
            {
              (async function () {
                var legenda = q ? q?.split("/")[0] : ` `
                var autor = q ? q?.split("/")[1] : q?.split("/")[0] ? '' : `  `
                if (isMedia && !info.message.videoMessage || isQuotedImage) {
                  var encmedia = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
                  rane = getRandom('.' + await getExtension(encmedia.mimetype))
                  buffimg = await getFileBuffer(encmedia, 'image')
                  fs.writeFileSync(rane, buffimg)
                  rano = getRandom('.webp')
                  exec(`ffmpeg -i ${rane} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${rano}`, (err) => {
                    fs.unlinkSync(rane)
                    // "android-app-store-link": "https://play.google.com/store/search?q=%2B55%2094%209147-2796%20%F0%9F%94%A5%F0%9F%94%A5%F0%9F%94%A5%F0%9F%94%A5%F0%9F%94%A5&c=apps",
                    var json = {
                      "sticker-pack-name": legenda,
                      "sticker-pack-publisher": autor
                    }
                    var exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00])
                    var jsonBuff = Buffer.from(JSON.stringify(json), "utf-8")
                    var exif = Buffer.concat([exifAttr, jsonBuff])
                    exif.writeUIntLE(jsonBuff.length, 14, 4)
                    let nomemeta = Math.floor(Math.random() * (99999 - 11111 + 1) + 11111) + ".temp.exif"
                    fs.writeFileSync(`./${nomemeta}`, exif)
                    exec(`webpmux -set exif ${nomemeta} ${rano} -o ${rano}`, () => {
                      client.sendMessage(from, { sticker: fs.readFileSync(rano) }, { quoted: info })
                      fs.unlinkSync(nomemeta)
                      fs.unlinkSync(rano)
                    })
                  })
                } else if (isMedia && info.message.videoMessage.seconds < 11 || isQuotedVideo && info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 35) {
                  var encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
                  rane = getRandom('.' + await getExtension(encmedia.mimetype))
                  buffimg = await getFileBuffer(encmedia, 'video')
                  fs.writeFileSync(rane, buffimg)
                  rano = getRandom('.webp')
                  await ffmpeg(`./${rane}`)
                    .inputFormat(rane.split('.')[1])
                  exec(`ffmpeg -i ${rane} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 200:200 ${rano}`, (err) => {
                    fs.unlinkSync(rane)
                    let json = {
                      "sticker-pack-name": legenda,
                      "sticker-pack-publisher": autor
                    }
                    let exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00])
                    let jsonBuff = Buffer.from(JSON.stringify(json), "utf-8")
                    let exif = Buffer.concat([exifAttr, jsonBuff])
                    exif.writeUIntLE(jsonBuff.length, 14, 4)
                    let nomemeta = "temp.exif"
                    fs.writeFileSync(`./${nomemeta}`, exif)
                    exec(`webpmux -set exif ${nomemeta} ${rano} -o ${rano}`, () => {
                      client.sendMessage(from, { sticker: fs.readFileSync(rano) }, { quoted: info })
                      fs.unlinkSync(nomemeta)
                      fs.unlinkSync(rano)
                    })
                  })
                } else {
                  reply(`Voc√™ precisa enviar ou marcar uma imagem ou v√≠deo com no m√°ximo 10 segundos`)
                }
              })().catch(e => {
                console.log(e)
                reply("Hmm deu erro")
                try {
                  if (fs.existsSync("temp.exif")) fs.unlinkSync("temp.exif");
                  if (fs.existsSync(rano)) fs.unlinkSync(rano);
                  if (fs.existsSync(media)) fs.unlinkSync(media);
                } catch { }
              })
            }
            break

          case "menuadm": {
            // client.sendMessage(from, { react: { text: `üçâ`, key: info.key }})
            /*
            const buttons = [
            //  {buttonId: 'id', buttonText: {displayText: '[üëë]  [üëë]'}, type: 1},
              {buttonId: `${prefix}ping`, buttonText: {displayText: '[üèì] ùôãùôÑùôâùôÇ [üèì]'}, type: 1},
              {buttonId: `${prefix}infodono`, buttonText: {displayText: '[üç∑] ùòøùôäùôâùôä [üç∑]'}, type: 1}
            ]
            */

            reply(`
  ‚ï≠‚îÄ‚ä£„Äò ${nomeBot} „Äô
  ‚ïë
  ‚ï†üçâ‚ûΩùêîùêôùêîùêÄùêëùêàùêé: ${pushname}
  ‚ï†üçâ‚ûΩùêïùêÑùêëùêí√Éùêé: 1.0
  ‚ï†üçâ‚ûΩùêçùêéùêåùêÑ:  ${pushname}
  ‚ïë
  ‚ïë‚ï≠‚îÄ‚ä£„Äò MENUS „Äô
  ‚ïë
  ‚ï†üçâ‚ûΩ${prefix}antilink 1/0
  ‚ï†üçâ‚ûΩ${prefix}Bemvindo 1 / 0
  ‚ï†üçâ‚ûΩ${prefix}antiaudio 1 / 0
  ‚ï†üçâ‚ûΩ${prefix}antivideo 1 / 0
  ‚ï†üçâ‚ûΩ${prefix}tagall (marcar todos) 
  ‚ï†üçâ‚ûΩ${prefix}marcar (marcar todos) 
  ‚ï†üçâ‚ûΩ${prefix}Antiimg 1 / 0
  ‚ï†üçâ‚ûΩ${prefix}antisticker 1/0
  ‚ï†üçâ‚ûΩ${prefix}autorea√ß√£o
  ‚ï†üçâ‚ûΩ${prefix}autofig 1/0
  ‚ï†üçâ‚ûΩ${prefix}hidetag [marcar todos] 
  ‚ï†üçâ‚ûΩ${prefix}descgp
  ‚ï†üçâ‚ûΩ${prefix}nomegp
  ‚ï†üçâ‚ûΩ${prefix}fotogp
  ‚ï†üçâ‚ûΩ${prefix}clear
  ‚ï†üçâ‚ûΩ${prefix}limpar
  ‚ï†üçâ‚ûΩ${prefix}delete
  ‚ï†üçâ‚ûΩ${prefix}d
  ‚ï†üçâ‚ûΩ${prefix}novolink
  ‚ï†üçâ‚ûΩ${prefix}infogp
  ‚ï†üçâ‚ûΩ${prefix}abrirgp
  ‚ï†üçâ‚ûΩ${prefix}status
  ‚ï†üçâ‚ûΩ${prefix}fechagp
  ‚ï†üçâ‚ûΩ${prefix}ban @numero
  ‚ï†üçâ‚ûΩ${prefix}sairgp
  ‚ï†üçâ‚ûΩ${prefix}reviver [marcar a msg]
  ‚ï†üçâ‚ûΩ${prefix}kick @numero
  ‚ï†üçâ‚ûΩ${prefix}add @numero
  ‚ï†üçâ‚ûΩ${prefix}linkgp
  ‚ï†üçâ‚ûΩ${prefix}promover @numero
  ‚ï†üçâ‚ûΩ${prefix}rebaixar @numero
  ‚ï†üçâ‚ûΩ${prefix}dellistanegra
  ‚ï†üçâ‚ûΩ${prefix}addlistanegra
  ‚ï†üçâ‚ûΩ${prefix}addlista [adiciona na lista de autoban]
  ‚ï†üçâ‚ûΩ${prefix}dellista [deleta da lista de autoban]
  ‚ï†üçâ‚ûΩ${prefix}listban
  ‚ï†üçâ‚ûΩ${prefix}autoban [modo de ban]
  ‚ï†üçâ‚ûΩ${prefix}kickfake [remove todos fake]
  ‚ï†üçâ‚ûΩ${prefix}banfake [remove todos fake]
  ‚ï†üçâ‚ûΩ${prefix}configp
  ‚ïë
  ‚ïö‚ïê‚ïê‚ïê‚ïê‚Ä¢ „Äò${nomeBot}„Äô‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
  `)
          }
            break
          case "menupremium": {
            reply(`
  ‚ï≠‚îÄ‚ä£„Äò ${nomeBot} „Äô
  ‚ïë
  ‚ï†üçâ‚ûΩùêîùêôùêîùêÄùêëùêàùêé: ${pushname}
  ‚ï†üçâ‚ûΩùêïùêÑùêëùêí√Éùêé: 1.0
  ‚ï†üçâ‚ûΩùêçùêéùêåùêÑ:  ${pushname}
  ‚ïë
  ‚ïë‚ï≠‚îÄ‚ä£„Äò MENUS „Äô
  ‚ïë
  ‚ï†üçâ‚ûΩ${prefix}ddd
  ‚ï†üçâ‚ûΩ${prefix}walpaperanime
  ‚ï†üçâ‚ûΩ${prefix}encurtalink
  ‚ï†üçâ‚ûΩ${prefix}gerarcpf
  ‚ï†üçâ‚ûΩ${prefix}clima
  ‚ï†üçâ‚ûΩ${prefix}gruposwa
  ‚ï†üçâ‚ûΩ${prefix}getquoted
  ‚ï†üçâ‚ûΩ${prefix}premiumlist
  ‚ï†üçâ‚ûΩ${prefix}configp
  ‚ïë
  ‚ïö‚ïê‚ïê‚ïê‚ïê‚Ä¢ „Äò${nomeBot}„Äô‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
  `)
          }
            break

          case "menubrincadeiras":
          case "brincadeira":
            reply(`
  ‚ï≠‚îÄ‚ä£„Äò ${nomeBot} „Äô
  ‚ïë
  ‚ï†üçâ‚ûΩùêîùêôùêîùêÄùêëùêàùêé: ${pushname}
  ‚ï†üçâ‚ûΩùêïùêÑùêëùêí√Éùêé: 1.0
  ‚ï†üçâ‚ûΩùêçùêéùêåùêÑ:  ${pushname}
  ‚ïë
  ‚ïë‚ï≠‚îÄ‚ä£„Äò MENUS „Äô
  ‚îÉüçâ‚ûΩ${prefix}fazernick
  ‚îÉüçâ‚ûΩ${prefix}Pau
  ‚îÉüçâ‚ûΩ${prefix}ppt
  ‚îÉüçâ‚ûΩ${prefix}Gadometro
  ‚îÉüçâ‚ûΩ${prefix}Chance (Texto)
  ‚îÉüçâ‚ûΩ${prefix}cassino 
  ‚îÉüçâ‚ûΩ${prefix}casal
  ‚îÉüçâ‚ûΩ${prefix}shipo
  ‚îÉüçâ‚ûΩ${prefix}alma-gemeas
  ‚îÉüçâ‚ûΩ${prefix}gay
  ‚îÉüçâ‚ûΩ${prefix}feio
  ‚îÉüçâ‚ûΩ${prefix}vesgo
  ‚îÉüçâ‚ûΩ${prefix}bebado
  ‚îÉüçâ‚ûΩ${prefix}gado
  ‚îÉüçâ‚ûΩ${prefix}gostoso
  ‚îÉüçâ‚ûΩ${prefix}gostosa
  ‚îÉüçâ‚ûΩ${prefix}rankgay
  ‚îÉüçâ‚ûΩ${prefix}rankgado
  ‚îÉüçâ‚ûΩ${prefix}rankcorno
  ‚ïë
  ‚ïö‚ïê‚ïê‚ïê‚ïê‚Ä¢ „Äò${nomeBot}„Äô‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
  `)

            break



          case 'rankgostosos':
          case 'rankgostoso':
            if (!isGroup) return reply('S√≥ pode ser utilizado este comando, em grupo.')

            member = []
            const p01 = groupMembers
            const p02 = groupMembers
            const p03 = groupMembers
            const p04 = groupMembers
            const p05 = groupMembers
            const o01 = p01[Math.floor(Math.random() * p01.length)]
            const o02 = p02[Math.floor(Math.random() * p02.length)]
            const o03 = p03[Math.floor(Math.random() * p03.length)]
            const o04 = p04[Math.floor(Math.random() * p04.length)]
            const o05 = p05[Math.floor(Math.random() * p05.length)]
            luy = `
  Parados!ü§öü§ö\n\n1=ü§öü§≠@${o01.id.split('@')[0]}ü§öü§≠\n\n\n2=ü§öü§≠@${o02.id.split('@')[0]}ü§öü§≠\n\n\n3=ü§öü§≠@${o03.id.split('@')[0]}ü§öü§≠\n\n\n4=ü§öü§≠@${o04.id.split('@')[0]}ü§öü§≠\n\n\n5=ü§öü§≠@${o05.id.split('@')[0]}ü§öü§≠\n\n\nMulta por serem gostosos dmsüò≥ pague pena trabalhando em nossa ag√™ncia de modelos üòä by: ${nomeBot}`
            member.push(o01.id)
            member.push(o02.id)
            member.push(o03.id)
            member.push(o04.id)
            member.push(o05.id)
            mentions(luy, member, true)
            break

          case 'rankgay':
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            membr = []
            var porcentagem = `${Math.floor(Math.random() * 105)}`
            const gay1 = groupMembers
            const gay2 = groupMembers
            const gay3 = groupMembers
            const gay4 = groupMembers
            const gay5 = groupMembers
            var porcent = porcentagem[Math.floor(Math.random() * porcentagem.length)]
            var porcent2 = porcentagem[Math.floor(Math.random() * porcentagem.length)]
            var porcent3 = porcentagem[Math.floor(Math.random() * porcentagem.length)]
            var porcent4 = porcentagem[Math.floor(Math.random() * porcentagem.length)]
            var porcent5 = porcentagem[Math.floor(Math.random() * porcentagem.length)]
            const gays1 = gay1[Math.floor(Math.random() * gay1.length)]
            const gays2 = gay2[Math.floor(Math.random() * gay2.length)]
            const gays3 = gay3[Math.floor(Math.random() * gay3.length)]
            const gays4 = gay4[Math.floor(Math.random() * gay4.length)]
            const gays5 = gay5[Math.floor(Math.random() * gay5.length)]
            rankzingay = `
  *Esses s√£o os Gaysüè≥Ô∏è‚Äçüåà do grupo:*\n${groupName}\n
  *‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*
  *‚îÇ* üè≥Ô∏è‚Äçüåà @${gays1.id.split('@')[0]}
  *‚îÇüçâ‚ûΩ ${porcent} Gay Padr√£o*
  *‚îÇ* üè≥Ô∏è‚Äçüåà @${gays2.id.split('@')[0]}
  *‚îÇüçâ‚ûΩ${porcent2}Gay Incubado*
  *‚îÇ* üè≥Ô∏è‚Äçüåà @${gays3.id.split('@')[0]}
  *‚îÇüçâ‚ûΩ ${porcent3} Gay Barbie*
  *‚îÇ* üè≥Ô∏è‚Äçüåà @${gays4.id.split('@')[0]}
  *‚îÇüçâ‚ûΩ ${porcent4} Gay Ativo*
  *‚îÇ* üè≥Ô∏è‚Äçüåà @${gays5.id.split('@')[0]}
  *‚îÇüçâ‚ûΩ ${porcent5} Gay Passivo*
  *‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*
  \n*üî•${nomeBot}üî•*`
            membr.push(gays1.id)
            membr.push(gays2.id)
            membr.push(gays3.id)
            membr.push(gays4.id)
            membr.push(gays5.id)
            client.sendMessage(from, { text: rankzingay, mentions: membr }, { quoted: live })
            break
          case 'rankcorno':
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            var porcentagem = `${Math.floor(Math.random() * 105)}`
            membr = []
            const corno1 = groupMembers
            const corno2 = groupMembers
            const corno3 = groupMembers
            const corno4 = groupMembers
            const corno5 = groupMembers
            var porcent = porcentagem[Math.floor(Math.random() * porcentagem.length)]
            var porcent2 = porcentagem[Math.floor(Math.random() * porcentagem.length)]
            var porcent3 = porcentagem[Math.floor(Math.random() * porcentagem.length)]
            var porcent4 = porcentagem[Math.floor(Math.random() * porcentagem.length)]
            var porcent5 = porcentagem[Math.floor(Math.random() * porcentagem.length)]
            const cornos1 = corno1[Math.floor(Math.random() * corno1.length)]
            const cornos2 = corno2[Math.floor(Math.random() * corno2.length)]
            const cornos3 = corno3[Math.floor(Math.random() * corno3.length)]
            const cornos4 = corno4[Math.floor(Math.random() * corno4.length)]
            const cornos5 = corno5[Math.floor(Math.random() * corno5.length)]
            rankzincorno = `
  *Esses s√£o os CornosüêÇ do grupo:*\n${groupName}\n
  *‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*
  *‚îÇ* üêÇ @${cornos1.id.split('@')[0]}
  *‚îÇüçâ‚ûΩ ${porcent} Corno Comum*
  *‚îÇ* üêÇ @${cornos2.id.split('@')[0]}
  *‚îÇüçâ‚ûΩ ${porcent2} Corno Manso*
  *‚îÇ* üêÇ @${cornos3.id.split('@')[0]}
  *‚îÇüçâ‚ûΩ ${porcent3} Corno Conformado*
  *‚îÇ* üêÇ @${cornos4.id.split('@')[0]}
  *‚îÇüçâ‚ûΩ ${porcent4} Corno Hiper-Chifrudo*
  *‚îÇ* üêÇ @${cornos5.id.split('@')[0]}
  *‚îÇüçâ‚ûΩ ${porcent5} Mestre Do Free Fire*
  *‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*
  \n*üî•${nomeBot}üî•*`
            membr.push(cornos1.id)
            membr.push(cornos2.id)
            membr.push(cornos3.id)
            membr.push(cornos4.id)
            membr.push(cornos5.id)
            client.sendMessage(from, { text: rankzincorno, mentions: membr }, { quoted: live })
            break

          case 'rankhetero':
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            var porcentagem = `${Math.floor(Math.random() * 105)}`
            membr = []
            const hetero1 = groupMembers
            const hetero2 = groupMembers
            const hetero3 = groupMembers
            const hetero4 = groupMembers
            const hetero5 = groupMembers
            var porcent = porcentagem[Math.floor(Math.random() * porcentagem.length)]
            var porcent2 = porcentagem[Math.floor(Math.random() * porcentagem.length)]
            var porcent3 = porcentagem[Math.floor(Math.random() * porcentagem.length)]
            var porcent4 = porcentagem[Math.floor(Math.random() * porcentagem.length)]
            var porcent5 = porcentagem[Math.floor(Math.random() * porcentagem.length)]
            const heteros1 = hetero1[Math.floor(Math.random() * hetero1.length)]
            const heteros2 = hetero2[Math.floor(Math.random() * hetero2.length)]
            const heteros3 = hetero3[Math.floor(Math.random() * hetero3.length)]
            const heteros4 = hetero4[Math.floor(Math.random() * hetero4.length)]
            const heteros5 = hetero5[Math.floor(Math.random() * hetero5.length)]
            rankzinhetero = `
  *Esses s√£o os H√©terosüí• do grupo:*\n${groupName}\n
  *‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*
  *‚îÇ* üí• @${heteros1.id.split('@')[0]}
  *‚îÇüçâ‚ûΩ ${porcent} H√©tero Comum*
  *‚îÇ* üí• @${heteros2.id.split('@')[0]}
  *‚îÇüçâ‚ûΩ ${porcent2} H√©tero Mandrake*
  *‚îÇ* üí• @${heteros3.id.split('@')[0]}
  *‚îÇüçâ‚ûΩ ${porcent3} H√©tero Curioso*
  *‚îÇ* üí• @${heteros4.id.split('@')[0]}
  *‚îÇüçâ‚ûΩ ${porcent4} H√©tero Top*
  *‚îÇ* üí• @${heteros5.id.split('@')[0]}
  *‚îÇüçâ‚ûΩ ${porcent5} H√©tero Cis*
  *‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*
  \n*üî•${nomeBot}üî•*`
            membr.push(heteros1.id)
            membr.push(heteros2.id)
            membr.push(heteros3.id)
            membr.push(heteros4.id)
            membr.push(heteros5.id)
            client.sendMessage(from, { text: rankzinhetero, mentions: membr }, { quoted: live })
            break

          case 'vesgo': // Sem Fotos
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            const aletttb = `${Math.floor(Math.random() * 105)}`
            reply('Aguarde, confiscando sua porcentagem...')
            await delay(5000)
            reply(`Sua Porcentagem De Vesgo √© De : ${aletttb}%`)
            break

          case 'bebado': // Sem Fotos
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            const alettb = `${Math.floor(Math.random() * 105)}`
            reply('Aguarde, confiscando sua porcentagem...')
            await delay(5000)
            reply(`Sua Porcentagem De bebado √© De : ${alettb}%`)
            break

          case 'feio': // Sem Fotos
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            const aletb = `${Math.floor(Math.random() * 105)}`
            reply('Aguarde, confiscando sua porcentagem...')
            await delay(5000)
            reply(`Sua Porcentagem De Feio √© De : ${aletb}%`)
            break

          case 'lindo':
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            const aletc = `${Math.floor(Math.random() * 105)}`
            reply('Aguarde, confiscando sua porcentagem...')
            await delay(5000)
            reply(`Sua Porcentagem De Lindo(a) √© De : ${aletc}%`)
            break

          case 'gostoso':
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            const aletd = `${Math.floor(Math.random() * 105)}`
            reply('Aguarde, confiscando sua porcentagem...')
            await delay(5000)
            reply(`Sua Porcentagem De Gostoso(a) √© De : ${aletd}%`)
            break

          case 'gostosa': {
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            const aletd = `${Math.floor(Math.random() * 105)}`
            reply('Aguarde, confiscando sua porcentagem...')
            await delay(5000)
            reply(`Sua Porcentagem De Gostoso(a) √© De : ${aletd}%`)
          }
            break

          case 'gado':
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            const alete = `${Math.floor(Math.random() * 105)}`
            reply('Aguarde, confiscando sua porcentagem...')
            await delay(5000)
            reply(`Sua Porcentagem De Gado(a) √© De : ${alete}%`)
            break

          case 'punheteiro':
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            const aletl = `${Math.floor(Math.random() * 105)}`
            reply('Aguarde, confiscando sua porcentagem...')
            await delay(5000)
            reply(`Sua Porcentagem De punheteiro(a) √© De : ${aletl}%`)
            break


          case 'gay':// Sem Fotos
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            const aleta = `${Math.floor(Math.random() * 105)}`
            reply('Aguarde, confiscando sua porcentagem...')
            await delay(5000)
            reply(`Sua Porcentagem De Gay √© De : ${aleta}%`)
            break

          case 'alma-gemeas':
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            if (!isGroup) return reply('S√≥ pode ser utilizado este comando, em grupo.')
            membr = []
            const suamae121 = groupMembers
            const suamae251 = groupMembers
            const teupai117 = suamae121[Math.floor(Math.random() * suamae121.length)]
            const teupai251 = suamae251[Math.floor(Math.random() * suamae251.length)]
            var shipted11 = ["1%", `2%`, `3%`, `4%`, `5%`, `6%`, `7`, `%`, `9%`, `10`, `11%`, `12%`, `13%`, `14%`, `15%`, `16%`, `17%`, `1%`, `19%`, `20%`, `21%`, `22`, `23%`, `24%`, `25%`, `26%`, `27%`, `2%`, `27%`, `2%`, `29%`, `30%`, `31%`, `32%`, `33%`, `34%`, `35%`, `36%`, `37%`, `3%`, `39%`, `40%`, `41%`, `42%`, `43%`, `44%`, `45%`, `46%`, `47%`, `4%`, `49%`, `50%`, `51%`, `52%`, `53%`, `54%`, `55%`, `56%`, `57%`, `5%`, `59%`, `60%`, `61%`, `62%`, `63%`, `64%`, `65%`, `66%`, `67%`, `6%`, `69%`, `70%`, `71%`, `72%`, `73%`, `74%`, `75%`, `76%`, `77%`, `7%`, `79%`, `0%`, `1%`, `2%`, `5%`, `4%`, `5%`, `6%`, `7%`, `%`, `9%`, `90%`, `91%`, `92%`, `93%`, `94%`, `95%`, `96%`, `97%`, `9%`, `99%`, `100%`]
            const shipteddd = shipted11[Math.floor(Math.random() * shipted11.length)]
            jet = `*Hmmm....  alma-gemeas eles 2 üíòüíò*\n\n1= @${teupai117.id.split('@')[0]}\n2= @${teupai251.id.split('@')[0]}\ncom uma porcentagem de: ${shipteddd}`
            membr.push(teupai117.id)
            membr.push(teupai251.id)
            mentions(jet, membr, true)
            break


          case 'shipo':
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            teks = args.join(" ")
            if (teks.length < 10) return reply('Marque uma pessoa do grupo para encontrar o par dela')
            membrr = []
            const suamae111 = groupMembers
            const suamae211 = groupMembers
            const teupai111 = suamae111[Math.floor(Math.random() * suamae111.length)]
            const teupai211 = suamae211[Math.floor(Math.random() * suamae211.length)]
            var shipted1 = ["1%", `2%`, `3%`, `4%`, `5%`, `6%`, `7`, `%`, `9%`, `10`, `11%`, `12%`, `13%`, `14%`, `15%`, `16%`, `17%`, `1%`, `19%`, `20%`, `21%`, `22`, `23%`, `24%`, `25%`, `26%`, `27%`, `2%`, `27%`, `2%`, `29%`, `30%`, `31%`, `32%`, `33%`, `34%`, `35%`, `36%`, `37%`, `3%`, `39%`, `40%`, `41%`, `42%`, `43%`, `44%`, `45%`, `46%`, `47%`, `4%`, `49%`, `50%`, `51%`, `52%`, `53%`, `54%`, `55%`, `56%`, `57%`, `5%`, `59%`, `60%`, `61%`, `62%`, `63%`, `64%`, `65%`, `66%`, `67%`, `6%`, `69%`, `70%`, `71%`, `72%`, `73%`, `74%`, `75%`, `76%`, `77%`, `7%`, `79%`, `0%`, `1%`, `2%`, `5%`, `4%`, `5%`, `6%`, `7%`, `%`, `9%`, `90%`, `91%`, `92%`, `93%`, `94%`, `95%`, `96%`, `97%`, `9%`, `99%`, `100%`]
            const shiptedd = shipted1[Math.floor(Math.random() * shipted1.length)]
            jet = `*Hmmm.... Eu Shipo eles 2üíòüíò*\n\n1 = @${teupai111.id.split('@')[0]}\n2 = ${teks}\ncom uma porcentagem de: ${shiptedd}`
            membrr.push(teupai111.id)
            membrr.push(teupai211.id)
            mentions(jet, membrr, true)
            break
            
          case "tiktokvd": {
    if (q < 1) return reply("coloque o link do v√≠deo depois do comando");

    const url = q;
    const apiUrl = `https://tohsaka.onrender.com/api/dl/tiktok?link=${url}&apikey=adm`;

    fetch(apiUrl)
        .then(response => response.json())
        .then(data => {
        //console.log(data)
            if (data.resultado.videoSemWt) {
                client.sendMessage(from, {
                    video: { url: data.resultado.videoSemWt },
                    mimetype: 'video/mp4'
                });
            } else {
                return reply("N√£o foi poss√≠vel obter o v√≠deo. Verifique o link e tente novamente.");
            }
        })
        .catch(error => {
            console.error(error);
            return reply("Ocorreu um erro ao processar o pedido. Tente novamente mais tarde.");
        });
} break;


          case "Menudownload":
          case "menudownload":
          case "download":
            //client.sendMessage(from, { react: { text: `üí´`, key: info.key } })
            /*
            const buuuuuuuttons = [
            //  {buttonId: 'id', buttonText: {displayText: '[üëë]  [üëë]'}, type: 1},
              {buttonId: `${prefix}menuadm`, buttonText: {displayText: '[üí¶] ùôàùôÄùôâùôê ùòºùòøùôà [üí¶]'}, type: 1},
              {buttonId: `${prefix}infodono`, buttonText: {displayText: '[üç∑] ùòøùôäùôâùôä [üç∑]'}, type: 1}
            ]
            */
            const buottonMeessage = {
              image: { url: imagemdomenu },
              caption: `‚ï≠‚îÄ‚ä£„Äò ${nomeBot} „Äô
  ‚ïë
  ‚ï†üçâ‚ûΩùêîùêôùêîùêÄùêëùêàùêé: ${pushname}
  ‚ï†üçâ‚ûΩùêïùêÑùêëùêí√Éùêé: 1.0
  ‚ï†üçâ‚ûΩùêçùêéùêåùêÑ:  ${pushname}
  ‚ïë
  ‚ïë‚ï≠‚îÄ‚ä£„Äò MENUS „Äô
  ‚ïë
  ‚ï†üçâ‚ûΩ${prefix}tiktokvd (link)
  ‚ï†üçâ‚ûΩ${prefix}Play_audio (nome da musica)
  ‚ï†üçâ‚ûΩ${prefix}Play_video (nome do video)
  ‚ïë
  ‚ïö‚ïê‚ïê‚ïê‚ïê‚Ä¢ „Äò${nomeBot}„Äô‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
  `,
              footer: `  `,
              ///    buttons: buuuuuuuttons,
              headerType: 4
            }

            client.sendMessage(from, buottonMeessage)

            break
          case "menufigurinhas":
          case "menufig":
            reply(`
  ‚ï≠‚îÄ‚ä£„Äò ${nomeBot} „Äô
  ‚ïë
  ‚ï†üçâ‚ûΩùêîùêôùêîùêÄùêëùêàùêé: ${pushname}
  ‚ï†üçâ‚ûΩùêïùêÑùêëùêí√Éùêé: 1.0
  ‚ï†üçâ‚ûΩùêçùêéùêåùêÑ:  ${pushname}
  ‚ïë
  ‚ïë‚ï≠‚îÄ‚ä£„Äò MENUS „Äô
  ‚ïë
  ‚ï†üçâ‚ûΩ${prefix}attp [texto] 
  ‚ï†üçâ‚ûΩ${prefix}attp2 [texto] 
  ‚ï†üçâ‚ûΩ${prefix}attp3 [texto] 
  ‚ï†üçâ‚ûΩ${prefix}attp4 [texto] 
  ‚ï†üçâ‚ûΩ${prefix}attp5 [texto] 
  ‚ï†üçâ‚ûΩ${prefix}attp6 [texto] 
  ‚ï†üçâ‚ûΩ${prefix}ttp [texto] 
  ‚ï†üçâ‚ûΩ${prefix}sticker
  ‚ï†üçâ‚ûΩ${prefix}roubar [marcar a figu] 
  ‚ï†üçâ‚ûΩ${prefix}rename [marcar a figu]
  ‚ï†üçâ‚ûΩ${prefix}sfundo 
  ‚ïë
  ‚ïë
  ‚ïö‚ïê‚ïê‚ïê‚ïê‚Ä¢ „Äò${nomeBot}„Äô‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
  
  `)

            break

          case 'figfundo':
          case 'figvideo':
          case 'figusemfundo':
          case 'sfundo':
            if (!isQuotedImage) return reply(`Marque uma imagem`)
            if ((isMedia && !info.message.videoMessage || isQuotedImage) && args.length == 0) {
              manu = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info = message.imageMessage
              buff = await getFileBuffer(manu, 'image')
              bas64 = `data:image/jpeg;base64,${buff.toString('base64')}`
              anu = args.join(' ').split('|')
              satu = anu[0] !== '' ? anu[0] : `${pushname}`
              sd = `CRIADO POR ‚Üì${nomeBot}`
              dua = typeof anu[1] !== 'undefined' ? anu[1] : `${sd}`
              var mantap = await convertSticker(bas64, `${dua}`, `${satu}`)
              var sti = new Buffer.from(mantap, 'base64');
              client.sendMessage(from, { sticker: sti }, { quoted: info })
            } else {
              return reply(`So imagem mn -_-`)
            }
            break

          case 'rename':
          case 'roubar':
            if (!isQuotedSticker) return reply('Marque uma figurinha...')
            encmediats = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
            var kls = q
            var pack = kls.split("/")[0];
            var author2 = kls.split("/")[1];
            if (!q) return reply('*E o autor e o nome do pacote?*')
            if (!pack) return reply(`*por favor escreve o formato certo: ${prefix + command} sad/bla*`)
            if (!author2) return reply(`*por favor escreve o formato certo: ${prefix + command} sad/dms*`)
            bas64 = `data:image/jpeg;base64,${encmediats.toString('base64')}`
            var mantap = await convertSticker(bas64, `${author2}`, `${pack}`)
            var sti = new Buffer.from(mantap, 'base64');
            client.sendMessage(from, { sticker: sti, contextInfo: { externalAdReply: { title: `${pack}|${author2}`, body: "", previewType: "PHOTO", thumbnail: sti } } }, { quoted: live })
              .catch((err) => {
                reply(`‚ùé Error, tenta mais tarde`);
              })
            break

          case 'emoji': {
            if (!args.join(" ")) return reply('CAD√ä O EMOJI?')
            emoji.get(args.join(" ")).then(async (emoji) => {
              let mese = await client.sendMessage(from, { image: { url: emoji.images[4].url }, caption: "PRONTO!" }, { quoted: m })
              await client.sendMessage(from, { text: `!s` }, { quoted: live })
            }).catch(e => {
              reply("EMOJI N√ÉO ENCONTRADO, TENTE OUTRO EMOJI A√ç...")
            })
          }
            break

          //CASSINO
          case 'cassino':
            const soto = [
              'üçä : üçí : üçê',
              'üçí : üîî : üçä',
              'üçá : üçá : üçá',
              'üçä : üçã : üîî',
              'üîî : üçí : üçê',
              'üîî : üçí : üçä',
              'üçä : üçã : ??',
              'üçê : üçí : üçã',
              'üçê : üçê : üçê',
              'üçä : üçí : üçí',
              'üîî : üîî : üçá',
              'üçå : üçí : üîî',
              'üçê : üîî : üîî',
              'üçä : üçã : üçí',
              'üçã : üçã : üçå',
              'üîî : üîî : üçá',
              'üîî : üçê : üçá',
              'üîî : üîî : üîî',
              'üçí : üçí : üçí',
              'üçå : üçå : üçå'
            ]
            const mining = Math.ceil(Math.random() * 200) + 1
            var somtoy2 = sotoy[Math.floor(Math.random() * sotoy.length)]
            if ((somtoy2 == 'ü•ë : ü•ë : ü•ë') || (somtoy2 == 'üçâ : üçâ : üçâ') || (somtoy2 == 'üçì : üçì : üçì') || (somtoy2 == 'üçé : üçé : üçé') || (somtoy2 == 'üçç : üçç : üçç') || (somtoy2 == 'ü•ù : ü•ù : ü•ù') || (somtoy2 == 'üçë : üçë : üçë') || (somtoy2 == 'ü•• : ü•• : ü••') || (somtoy2 == 'üçã : üçã : üçã') || (somtoy2 == 'üçê : ?? : üçê') || (somtoy2 == 'üçå : üçå : üçå') || (somtoy2 == 'üçí : üçí : üçí') || (somtoy2 == 'üîî : üîî : üîî') || (somtoy2 == 'üçä : üçä : üçä') || (somtoy2 == 'üçá : üçá : üçá')) {
              var Vit√≥ria = "Voc√™ ganhou üîÆ"
            } else {
              var Vit√≥ria = "Voc√™ perdeu..."
            }
            /*
            let butttons = [
              {buttonId: `${prefix}cassino`, buttonText: {displayText: 'üí¶PR√ìXIMOüí¶'}, type: 1},
              ]
              */
            templateMassage = {
              text: `
  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïêü•áÔ∏é‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
  ‚î£‚ñ∫ ${somtoy2}‚óÑ‚îõ
  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïêü•áÔ∏é‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
  
  *${Vit√≥ria}*`,
              footer: `${nomeBot}`,
              headerType: 1
            }
            client.sendMessage(from, templateMassage)
            if (Vit√≥ria == "Voc√™ ganhou!!!") {
              reply('Parab√©ns')
            }
            break

          case 'chance':
            if (!isGroup) return reply('S√≥ pode ser utilizado este comando, em grupo.')
            var avb = body.slice(7)
            if (args.length < 1) return client.sendMessage(from, { text: `Voc√™ precisa digitar da forma correta\nExemplo: ${prefix}chance do luuck ser gay` }, { quoted: info })
            random = `${Math.floor(Math.random() * 100)}`
            hasil = `A chance ${body.slice(8)}\n\n√© de... ${random}%`
            await client.sendMessage(from, { text: hasil, contextInfo: { mentionedJid: [sender] } }, { quoted: info })
            break

          case 'gadometro':
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            var chifre = ["ultra extreme gado", "Gado-Master", "Gado-Rei", "Gado", "Escravo-ceta", "Escravo-ceta Maximo", "Gacorno?", "Jogador De Forno Livre<3", "Mestre Do Frifai<3<3", "Gado-Manso", "Gado-Conformado", "Gado-Incubado", "Gado Deus", "Mestre dos Gados", "Topa tudo por buceta", "Gado Comum", "Mini Gadinho", "Gado Iniciante", "Gado Basico", "Gado Intermediario", "Gado Avan√ßado", "Gado Profisional", "Gado Mestre", "Gado Chifrudo", "Corno Conformado", "Corno HiperChifrudo", "Chifrudo Deus", "Mestre dos Chifrudos"]
            var gado = chifre[Math.floor(Math.random() * chifre.length)]
            gadop = `${Math.floor(Math.random() * 100)}`
            hisil = `VOC√ä √â:\n\n${gado}`
            reply(hisil)
            break

          case 'pau'://Jogos
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            randommmm = `${Math.floor(Math.random() * 35)}`
            const tamanho = randommmm
            if (tamanho < 13) { pp = 's√≥ a fimose' } else if (tamanho == 13) { pp = 'passou da m√©diaüò≥' } else if (tamanho == 14) { pp = 'passou da m√©diaüò≥' } else if (tamanho == 15) { pp = 'eita, vai pegar manga?' } else if (tamanho == 16) { pp = 'eita, vai pegar manga?' } else if (tamanho == 17) { pp = 'calma man, a mina n√£o √© um po√ßoüò≥' } else if (tamanho == 18) { pp = 'calma man, a mina n√£o √© um po√ßoüò≥' } else if (tamanho == 19) { pp = 'calma man, a mina n√£o √© um po√ßoüò≥' } else if (tamanho == 20) { pp = 'voc√™ tem um poste no meio das pernas' } else if (tamanho == 21) { pp = 'voc√™ tem um poste no meio das pernas' } else if (tamanho == 22) { pp = 'voc√™ tem um poste no meio das pernas' } else if (tamanho == 23) { pp = 'voc√™ tem um poste no meio das pernas' } else if (tamanho == 24) { pp = 'voc√™ tem um poste no meio das pernas' } else if (tamanho > 25) {
              pp = 'vai procurar petr√≥leo com isso?'
            }
            hasil = `SEU PAU TEM ${randommmm}CM\n\n${pp}`
            reply(hasil)
            break


          case 'gay1':
            if (!isGroup) return reply(`S√≥ pode ser utilizado este comando, em grupo.`)
            if (args.length < 1) return reply('marque o gay do gp!')
            rate = body.slice(5)
            var ti = ['4', '9', '17', '28', '34', '48', '59', '62', '74', '83', '97', '100', '29', '94', '75', '82', '41', '39']
            var kl = ti[Math.floor(Math.random() * ti.length)]
            reply('COMO VOC√ä √â GAY: *' + rate + '*\n\nSUA PORCENTAGEM GAY : ' + kl + '%\n ESSE A√ç AMA D√Å O CU')
            break

          case 'Fazernick':
          case 'fazernick':
            let { styletext } = require('./functions/scraper')
            if (!q) return reply("kd o texto?")
            let anu = await styletext(q)
            let teks = `ùêãùêàùêíùêìùêÄ ùêÉùêÑ ùêçùêàùêÇùêäùêí: ${q}\n\n`
            for (let i of anu) {
              teks += `üçâ‚ûΩ ${i.result}\n\n`
            }
            reply(teks)
            break

          case 'getquoted':
          case 'getinfo':
          case 'get':
            if (!isPremium) return reply(resposta.premium)
            reply(JSON.stringify(info.message.extendedTextMessage.contextInfo, null, 3))
            break

          case 'encurtalink':
            if (!isPremium) return reply(resposta.premium)
            if (args.length < 1) return reply(`Exemplo:\n${prefix}encurtalink https://www.youtube.com/channel/UCgKrNnrbNPJIOjJOgIXe1vQ`)
            try {
              link = args[0]
              anu = await axios.get(`https://tinyurl.com/api-create.php?url=${link}`)
              reply(`${anu.data}`)
            } catch (e) {
              emror = String(e)
              reply(`${e}`)
            }
            await limitAdd(sender)
            break

          case 'ddd':
            if (!isPremium) return reply(resposta.premium)
            if (args.length < 1) return reply(`Use ${prefix + command} 21`)
            ddd = body.slice(5)
            ddds = await axios.get(`https://brasilapi.com.br/api/ddd/v1/${ddd}`)
            dddlist = `Lista de Cidades de ${ddds.data.state} com este DDD ${q}>\n\n`
            for (let i = 0; i < ddds.data.cities.length; i++) { dddlist += `${i + 1} ‚™ß *${ddds.data.cities[i]}*\n` }
            client.sendMessage(from, { text: dddlist }, { quoted: info })
            break

case 'menu':{
//client.sendMessage(from, { react: { text: `üçâ`, key: info.key }})
if(!isGroup){ 
const linka = "https://instagram.instagram.com/fantasmin.dev"
const buttonMessage = {
image: {url: "https://telegra.ph/file/745093b0e7d91bfac4eb5.jpg"},
caption:  `
‚ï≠‚îÄ‚ä£„Äò ${nomeBot} „Äô
‚ïë
‚ï†üçâ‚ûΩùêîùêôùêîùêÄùêëùêàùêé: ${pushname}
‚ï†üçâ‚ûΩùêïùêÑùêëùêí√Éùêé: 1.0.0
‚ï†üçâ‚ûΩùêçùêéùêåùêÑ:  ${pushname}
‚ïë
‚ïë‚ï≠‚îÄ‚ä£„Äò MENUS „Äô
‚ïë
‚ï†üçâ‚ûΩ${prefix}Alugar
‚ï†üçâ‚ûΩ${prefix}Menulogos
‚ï†üçâ‚ûΩ${prefix}Menubrincadeiras
‚ï†üçâ‚ûΩ${prefix}Menuadm
‚ï†üçâ‚ûΩ${prefix}Menupremium
‚ï†üçâ‚ûΩ${prefix}Menufig
‚ï†üçâ‚ûΩ${prefix}Menudownload
‚ï†üçâ‚ûΩ${prefix}Menulist
‚ï†üçâ‚ûΩ${prefix}Menudono
‚ï†üçâ‚ûΩ${prefix}Menuanime
‚ïë
‚ïë‚ï≠‚îÄ‚ä£„Äò ADICIONAIS „Äô
‚ïë
‚ï†üçâ‚ûΩ${prefix}anagrama
‚ï†üçâ‚ûΩ${prefix}ppt
‚ï†üçâ‚ûΩ${prefix}jokenpo
‚ï†üçâ‚ûΩ${prefix}adivinha√ß√£o 
‚ï†üçâ‚ûΩ${prefix}alugar
‚ï†üçâ‚ûΩ${prefix}comprabt
‚ï†üçâ‚ûΩ${prefix}convite [link do gp]
‚ï†üçâ‚ûΩ${prefix}ping
‚ï†üçâ‚ûΩ${prefix}metadinha
‚ï†üçâ‚ûΩ${prefix}metadinha2
‚ï†üçâ‚ûΩ${prefix}metadinha3
‚ï†üçâ‚ûΩ${prefix}perfil
‚ï†üçâ‚ûΩ${prefix}correio
‚ï†üçâ‚ûΩ${prefix}clima
‚ï†üçâ‚ûΩ${prefix}level
‚ï†üçâ‚ûΩ${prefix}gtts
‚ï†üçâ‚ûΩ${prefix}calcular [2 + 2]
‚ï†üçâ‚ûΩ${prefix}Fazernick [Nick]
‚ï†üçâ‚ûΩ${prefix}ranklevel
‚ï†üçâ‚ûΩ${prefix}google
‚ï†üçâ‚ûΩ${prefix}gerarcpf
‚ï†üçâ‚ûΩ${prefix}encurtalink
‚ï†üçâ‚ûΩ${prefix}ddd
‚ï†üçâ‚ûΩ${prefix}listabr
‚ï†üçâ‚ûΩ${prefix}listafake
‚ï†üçâ‚ûΩ${prefix}play_audio
‚ï†üçâ‚ûΩ${prefix}play_video
‚ï†üçâ‚ûΩ${prefix}ytmp4 (Link) 
‚ï†üçâ‚ûΩ${prefix}ytmp3 (Link) 
‚ï†üçâ‚ûΩ${prefix}bug
‚ï†üçâ‚ûΩ${prefix}avalie
‚ï†üçâ‚ûΩ${prefix}novocmd
‚ïë
‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚Ä¢ „Äò${nomeBot}„Äô‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
üëë Entre em contato: https://instagram.com/fantasmin.dev
`,
    footer: `üçâ${nomeBot}üçâ`,
  //  buttons: buttons,
    headerType: 4
}

client.sendMessage(from, buttonMessage)


} else if(isGroup){ 
client.sendMessage(from, { react: { text: `üçâ`, key: info.key }})
//reply(`${data.resultado}`)
let buttonMessage4 = {
image: { url: "https://telegra.ph/file/41e27ca006bb7488f155d.png"},
caption: `
‚ï≠‚îÄ‚ä£„Äò ${nomeBot} „Äô
‚ïë
‚ï†üçâ‚ûΩùêîùêôùêîùêÄùêëùêàùêé: ${pushname}
‚ï†üçâ‚ûΩùêïùêÑùêëùêí√Éùêé: 1.0.0
‚ï†üçâ‚ûΩùêçùêéùêåùêÑ:  ${pushname}
‚ïë
‚ïë‚ï≠‚îÄ‚ä£„Äò MENUS „Äô
‚ïë
‚ï†üçâ‚ûΩ${prefix}Alugar
‚ï†üçâ‚ûΩ${prefix}Menulogos
‚ï†üçâ‚ûΩ${prefix}Menubrincadeiras
‚ï†üçâ‚ûΩ${prefix}Menuadm
‚ï†üçâ‚ûΩ${prefix}Menupremium
‚ï†üçâ‚ûΩ${prefix}Menufig
‚ï†üçâ‚ûΩ${prefix}Menudownload
‚ï†üçâ‚ûΩ${prefix}Menulist
‚ï†üçâ‚ûΩ${prefix}Menudono
‚ï†üçâ‚ûΩ${prefix}Menuanime
‚ïë
‚ïë‚ï≠‚îÄ‚ä£„Äò ADICIONAIS „Äô
‚ïë
‚ï†üçâ‚ûΩ${prefix}anagrama
‚ï†üçâ‚ûΩ${prefix}ppt
‚ï†üçâ‚ûΩ${prefix}jokenpo
‚ï†üçâ‚ûΩ${prefix}adivinha√ß√£o 
‚ï†üçâ‚ûΩ${prefix}alugar
‚ï†üçâ‚ûΩ${prefix}comprabt
‚ï†üçâ‚ûΩ${prefix}convite [link do gp]
‚ï†üçâ‚ûΩ${prefix}ping
‚ï†üçâ‚ûΩ${prefix}metadinha
‚ï†üçâ‚ûΩ${prefix}metadinha2
‚ï†üçâ‚ûΩ${prefix}metadinha3
‚ï†üçâ‚ûΩ${prefix}perfil
‚ï†üçâ‚ûΩ${prefix}correiooranklevel
‚ï†üçâ‚ûΩ${prefix}google
‚ï†üçâ‚ûΩ${prefix}gerarcpf
‚ï†üçâ‚ûΩ${prefix}encurtalink
‚ï†üçâ‚ûΩ${prefix}ddd
‚ï†üçâ‚ûΩ${prefix}listabr
‚ï†üçâ‚ûΩ${prefix}listafake
‚ï†üçâ‚ûΩ${prefix}play_audio
‚ï†üçâ‚ûΩ${prefix}play_video
‚ï†üçâ‚ûΩ${prefix}ytmp4 (Link) 
‚ï†üçâ‚ûΩ${prefix}ytmp3 (Link) 
‚ï†üçâ‚ûΩ${prefix}bug
‚ï†üçâ‚ûΩ${prefix}avalie
‚ï†üçâ‚ûΩ${prefix}novocmd
‚ïë
‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚Ä¢ „Äò${nomeBot}„Äô‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`,
footer: '',
//buttons: buttons,
headerType: 4
}
client.sendMessage(from, buttonMessage4, { quoted: info })

}
}
break 

          case "cosplay":
          case "waifu":
          case "waifu2":
          case "shota":
          case "loli":
          case "yotsuba":
          case "shinomiya":
          case "yumeko":
          case "tejina":
          case "chiho":
          case "shizuka":
          case "boruto":
          case "kagori":
          case "kaga":
          case "kotori":
          case "mikasa":
          case "akiyama":
          case "hinata":
          case "minato":
          case "naruto":
          case "nezuko":
          case "yuki":
          case "hestia":
          case "emilia":
          case "itachi":
          case "elaina":
          case "madara":
          case "sasuke":
          case "deidara":
          case "sakura":
          case "tsunade":
            //reply("off no momento")
            try {
              client.sendMessage(from, { react: { text: 'üïö', key: info.key } })
              fetch(encodeURI(`https://fine-gold-squid-yoke.cyclic.app/nime/${command}?username=Teste&key=teste`))
                .then(response => response.json())
                .then(data => {
                  var resultado = data.url;

                  let buttonMessage4 = {
                    image: { url: `${resultado}` },
                    caption: `üèï Ol√° ${pushname}, aqui est√° sua imagem üé≤`,
                    footer: '',
                    //buttons: buttons,
                    headerType: 4
                  }
                  client.sendMessage(from, buttonMessage4, { quoted: info })
                })
            } catch (e) {
              console.log(e)
              reply("nao achei a foto, tente novamente mais tarde")
            }

            break

          case 'ahegao':
          case 'ass':
          case 'bdsm':
          case 'blowjob':
          case 'cuckold':
          case 'cum':
          case 'ero':
          case 'kasedaiki':
          case 'femdom':
          case 'foot':
          case 'gangbang':
          case 'glasses':
          case 'jahy':
          case 'manga':
          case 'masturbation':
          case 'neko':
          case 'orgy':
          case 'panties':
          case 'pussy':
          case 'neko2':
          case "neko":
          case 'tentacles':
          case 'thighs':
          case 'yuri':
          case 'zettai':
            //reply("off no momento")

            try {
              client.sendMessage(sender, { react: { text: 'üïö', key: info.key } })
              fetch(encodeURI(`https://fine-gold-squid-yoke.cyclic.app/nsfw/${command}?username=Teste&key=teste`))
                .then(response => response.json())
                .then(data => {
                  var resultado = data.url;

                  let buttonMessage4 = {
                    image: { url: `${resultado}` },
                    caption: `üèï Ol√° ${pushname}, aqui est√° sua imagem üé≤`,
                    footer: '',
                    //buttons: buttons,
                    headerType: 4
                  }
                  client.sendMessage(sender, buttonMessage4, { quoted: info })
                })
            } catch (e) {
              console.log(e)
              reply("nao achei a foto, tente novamente mais tarde")
            }

            break

          case "menudono":
            // client.sendMessage(from, { react: { text: `üçâ`, key: info.key }})

            const buuuttonMessage = {
              image: fs.readFileSync('./clover2.jpg'),
              caption: `
  ‚ï≠‚îÄ‚ä£„Äò ${nomeBot} „Äô
  ‚ïë
  ‚ï†üçâ‚ûΩùêîùêôùêîùêÄùêëùêàùêé: ${pushname}
  ‚ï†üçâ‚ûΩùêïùêÑùêëùêí√Éùêé: 1.0.0
  ‚ï†üçâ‚ûΩùêçùêéùêåùêÑ:  ${pushname}
  ‚ïë
  ‚ïë‚ï≠‚îÄ‚ä£„Äò MENUS „Äô
  ‚ïë
  ‚ï†üçâ‚ûΩ${prefix}premiumlist
  ‚ï†üçâ‚ûΩ${prefix}addpremium @
  ‚ï†üçâ‚ûΩ${prefix}delpremium @
  ‚ï†üçâ‚ûΩ${prefix}bangp
  ‚ï†üçâ‚ûΩ${prefix}transmitir 
  ‚ï†üçâ‚ûΩ${prefix}unbangp
  ‚ï†üçâ‚ûΩ${prefix}reviverqr
  ‚ï†üçâ‚ûΩ${prefix}arquivargp
  ‚ï†üçâ‚ûΩ${prefix}nuke
  ‚ï†üçâ‚ûΩ${prefix}entrar [link do gp]
  ‚ï†üçâ‚ûΩ${prefix}antipv 1
  ‚ï†üçâ‚ûΩ${prefix}antipv 0
  ‚ï†üçâ‚ûΩ${prefix}fotobot  
  ‚ï†üçâ‚ûΩ${prefix}seradm 
  ‚ï†üçâ‚ûΩ${prefix}sermembro 
  ‚ï†üçâ‚ûΩ${prefix}listagp 
  ‚ï†üçâ‚ûΩ${prefix}banghost 
  ‚ï†üçâ‚ûΩ${prefix}serpremium
  ‚ï†üçâ‚ûΩ${prefix}antipv 1/0
  ‚ïë
  ‚ïö‚ïê‚ïê‚ïê‚ïê‚Ä¢ „Äò${nomeBot}„Äô‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
  
  `,
              footer: `  `,
              //    buttons: buuottons,
              headerType: 4
            }

            client.sendMessage(from, buuuttonMessage)
            break

          case "menuanime":
            client.sendMessage(from, { react: { text: `‚ú®`, key: info.key } })
            reply(`
  ‚ï≠‚îÄ‚ä£„Äò ${nomeBot} „Äô
  ‚ïë
  ‚ï†üçâ‚ûΩùêîùêôùêîùêÄùêëùêàùêé: ${pushname}
  ‚ï†üçâ‚ûΩùêïùêÑùêëùêí√Éùêé: 1.0.0
  ‚ï†üçâ‚ûΩùêçùêéùêåùêÑ:  ${pushname}
  ‚ïë
  ‚ïë‚ï≠‚îÄ‚ä£„Äò MENUS „Äô
  ‚ïë
  ‚ï†üçâ‚ûΩ${prefix}cosplay
  ‚ï†üçâ‚ûΩ${prefix}waifu
  ‚ï†üçâ‚ûΩ${prefix}waifu2
  ‚ï†üçâ‚ûΩ${prefix}shota
  ‚ï†üçâ‚ûΩ${prefix}loli
  ‚ï†üçâ‚ûΩ${prefix}yotsuba
  ‚ï†üçâ‚ûΩ${prefix}shinomiya
  ‚ï†üçâ‚ûΩ${prefix}yumeko
  ‚ï†üçâ‚ûΩ${prefix}tejina
  ‚ï†üçâ‚ûΩ${prefix}chiho
  ‚ï†üçâ‚ûΩ${prefix}shizuka
  ‚ï†üçâ‚ûΩ${prefix}boruto
  ‚ï†üçâ‚ûΩ${prefix}kagori
  ‚ï†üçâ‚ûΩ${prefix}kaga
  ‚ï†üçâ‚ûΩ${prefix}kotori
  ‚ï†üçâ‚ûΩ${prefix}mikasa
  ‚ï†üçâ‚ûΩ${prefix}akiyama
  ‚ï†üçâ‚ûΩ${prefix}hinata
  ‚ï†üçâ‚ûΩ${prefix}minato
  ‚ï†üçâ‚ûΩ${prefix}naruto
  ‚ï†üçâ‚ûΩ${prefix}nezuko
  ‚ï†üçâ‚ûΩ${prefix}yuki
  ‚ï†üçâ‚ûΩ${prefix}hestia
  ‚ï†üçâ‚ûΩ${prefix}emilia
  ‚ï†üçâ‚ûΩ${prefix}itachi
  ‚ï†üçâ‚ûΩ${prefix}madara
  ‚ï†üçâ‚ûΩ${prefix}sasuke
  ‚ï†üçâ‚ûΩ${prefix}deidara
  ‚ï†üçâ‚ûΩ${prefix}sakura
  ‚ï†üçâ‚ûΩ${prefix}tsunade
  ‚îÉ
  ‚îù‚îÅ„Ä¢ üçâ Hentai/+18 no pv
  ‚îÉ
  ‚ï†üçâ‚ûΩ ${prefix}ahegao
  ‚ï†üçâ‚ûΩ ${prefix}ass
  ‚ï†üçâ‚ûΩ ${prefix}bdsm
  ‚ï†üçâ‚ûΩ ${prefix}blowjob
  ‚ï†üçâ‚ûΩ ${prefix}cuckold
  ‚ï†üçâ‚ûΩ ${prefix}cum
  ‚ï†üçâ‚ûΩ ${prefix}ero
  ‚ï†üçâ‚ûΩ ${prefix}kasedaiki
  ‚ï†üçâ‚ûΩ ${prefix}femdom
  ‚ï†üçâ‚ûΩ ${prefix}foot
  ‚ï†üçâ‚ûΩ ${prefix}gangbang
  ‚ï†üçâ‚ûΩ ${prefix}glasses
  ‚ï†üçâ‚ûΩ ${prefix}jahy
  ‚ï†üçâ‚ûΩ ${prefix}manga
  ‚ï†üçâ‚ûΩ ${prefix}masturbation
  ‚ï†üçâ‚ûΩ ${prefix}neko
  ‚ï†üçâ‚ûΩ ${prefix}orgy
  ‚ï†üçâ‚ûΩ ${prefix}panties
  ‚ï†üçâ‚ûΩ ${prefix}pussy
  ‚ï†üçâ‚ûΩ ${prefix}neko2
  ‚ï†üçâ‚ûΩ ${prefix}tentacles
  ‚ï†üçâ‚ûΩ ${prefix}thighs
  ‚ï†üçâ‚ûΩ ${prefix}yuri
  ‚ï†üçâ‚ûΩ ${prefix}zettai
  ‚ïë
  ‚ïö‚ïê‚ïê‚ïê‚ïê‚Ä¢ „Äò${nomeBot}„Äô‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
  `)
            break


          case 'listagp':
            try {
              if (!isOwner) return reply(resposta.dono)
              let getGroups = await client.groupFetchAllParticipating()
              let groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
              if (q.includes("-l") || q.includes("--list")) {
                array_gps = [];
                for (let a of groups) {
                  try {
                    array_gps.push({
                      title: `‚Äçùó°ùóºùó∫ùó≤: ${a.subject}`,
                      description: `ùóúùó±: ${a.id}\nùó†ùó≤ùó∫ùóØùóøùóºùòÄ: ${a.participants.length}`,
                      rowId: `${prefix + command} ${a.id}`
                    })
                  } catch { }
                }
                buttonmessage02 = {
                  title: `Lista de grupos`,
                  text: `Selecione um grupo para mais detalhes`,
                  buttonText: "Selecionar",
                  sections: [
                    {
                      rows: array_gps
                    }
                  ]
                }
                client.sendMessage(from, buttonmessage02, { quoted: info })
              } else if (q && args[0].endsWith("g.us")) {
                try {
                  let infogp = await client.groupMetadata(`${args[0]}`)
                  try {
                    ppUrl = await client.profilePictureUrl(`${args[0]}`, 'image')
                  } catch { ppUrl = "https://telegra.ph/file/41634a68c48c40189dbf7.jpg" }
                  try {
                    linkgc = await client.groupInviteCode(infogp.id)
                    linkgp = 'https://chat.whatsapp.com/' + linkgc
                  } catch { linkgp = "Bot n√£o √© admin" }
                  txt =
                    `ùó°ùóºùó∫ùó≤ ùó±ùóº ùó¥ùóøùòÇùóΩùóº: ${infogp.subject}
  ùóóùóºùóªùóº: ${infogp.owner ? infogp.owner : "N√£o tem"}
  ùó†ùó≤ùó∫ùóØùóøùóºùòÄ: ${infogp.participants.length}
  ùóúùó±: ${infogp.id}
  ùóüùó∂ùóªùó∏: ${linkgp}
  `
                  await client.sendMessage(from, { image: { url: ppUrl }, caption: txt, thumbnail: null, mentions: [sender] }, { quoted: info })
                } catch { }
              } else {
                txt = "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                array_owners = [];
                for (let a of groups) {
                  txt += `ùó°ùóºùó∫ùó≤ ùó±ùóº ùó¥ùóøùòÇùóΩùóº: ${a.subject}
  ùóóùóºùóªùóº / ùó∞ùóøùó∂ùóÆùó±ùóºùóø: @${a.owner ? a.owner.split("@")[0] : "N√£o tem"}
  ùó†ùó≤ùó∫ùóØùóøùóºùòÄ: ${a.participants.length}
  ùóúùó±: ${a.id}\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n
  `
                  if (a.owner !== undefined) {
                    array_owners.push(`${a.owner}`)
                  }
                }
                client.sendMessage(from, { text: txt, mentions: array_owners })
              }
            } catch {
              reply("Hmm deu erro")
            }
            break

          case 'banghost':
          case 'banghosts':
            if (!isGroup) return reply(resposta.grupo)
            if (!isOwner) return reply("S√≥ dono pode executar este comando..")
            if (!isBotGroupAdmins) return reply('Bot precisa ser ADM, para executar esta fun√ß√£o.')
            if (q.length < 1) return reply(`Exemplo: ${prefix}banghosts 0\n\nEle vai banir todos aqueles que t√° com 0 mensagens, mas fa√ßa isso apenas se passou um tempo com o bot armazenando mensagem dos membros ativos do grupo.`)
            async function banghst() {
              if (groupIdscount.indexOf(from) >= 0) {
                for (let obj of groupMembers) {
                  if (numbersIds.indexOf(obj.id) >= 0) {
                    var indnum = numbersIds.indexOf(obj.id)
                    if (countMessage[ind].numbers[indnum].messages <= args[0]) {
                      if (groupAdmins.includes(obj.id)) return mentions(`@${obj.id} ta liberado da inspe√ß√£o por ser admin`, [obj.id], true)
                      if (numerodono.includes(obj.id)) return mentions(`@${obj.id} ta liberado da inspe√ß√£o por ser dono`, [obj.id], true)
                      client.groupParticipantsUpdate(from, [obj.id], 'remove')
                    }
                  }
                }
              }
            }
            setInterval(banghst, 1000)
            break

          case 'seradm': {
            if (!isOwner) return reply(resposta.dono)
            reply(`Agora vc √© adm do grupo.`)
            kiceed = sender
            client.groupParticipantsUpdate(from, [kiceed], 'promote')
          }
            break

          case 'sermembro': {
            if (!isOwner) return reply(resposta.dono)
            reply(`Agora vc n√£o √© mais adm do grupo.`)
            kicee = sender
            await client.groupParticipantsUpdate(from, [kicee], 'demote')
          }
            break

          case 'fotobot':
            if (!isOwner) return reply(resposta.dono)
            if (!isQuotedImage) return reply(`Envie fotos com legendas ${prefix}fotobot ou tags de imagem que j√° foram enviadas`)
            buff = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage, 'image')
            await client.updateProfilePicture(botNumber, buff)
            reply('Obrigado pelo novo perfil vlw')
            break

          case 'reviverqr':
            if (!isOwner) return reply(resposta.dono)
            exec("cd conex√£o akame.json* && rm -rf pre-key* sender* session*")
            setTimeout(async () => {
              reply("Reiniciando..")
              setTimeout(async () => {
                process.exit()
              }, 1200)
            }, 1000)
            break

          case 'addpremium':
            if (!isGroup) return reply(resposta.grupo)
            if (!isOwner) return reply(resposta.dono)
            if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return
            if (!budy.includes("@55")) {
              mentioned = info.message.extendedTextMessage.contextInfo.participant
              bla = premium.includes(mentioned)
              if (bla) return reply("*Este n√∫mero j√° est√° incluso..*")
              premium.push(`${mentioned}`)
              fs.writeFileSync('./functions/premium.json', JSON.stringify(premium))
              client.sendMessage(from, { text: `üëë@${mentioned.split("@")[0]} foi adicionado √† lista de usu√°rios premium com sucessoüëë` }, { quoted: info })
            } else {
              mentioned = args.join(" ").replace("@", "") + "@s.whatsapp.net"
              bla = premium.includes(mentioned)
              if (bla) return reply("*Este n√∫mero j√° est√° incluso..*")
              premium.push(`${mentioned}`)
              fs.writeFileSync('./functions/premium.json', JSON.stringify(premium))
              tedtp = args.join(" ").replace("@", "")
              client.sendMessage(from, { text: `üëë@${tedtp} foi adicionado √† lista de usu√°rios premium com sucessoüëë`, mentions: [mentioned] }, { quoted: info })
            }
            break

          case 'delpremium':
            if (!isGroup) return reply(resposta.grupo)
            if (!isOwner) return reply(resposta.dono)
            if (!budy.includes("@55")) {
              num = info.message.extendedTextMessage.contextInfo.participant
              bla = premium.includes(num)
              if (!bla) return reply("*Este n√∫mero n√£o est√° incluso na lista premium..*")
              pesquisar = num
              processo = premium.indexOf(pesquisar)
              while (processo >= 0) {
                premium.splice(processo, 1)
                processo = premium.indexOf(pesquisar)
              }
              fs.writeFileSync('./functions/premium.json', JSON.stringify(premium))
              client.sendMessage(from, { text: ` ${num.split("@")[0]} foi tirado da lista premium com sucesso..` }, { quoted: info })
            } else {
              mentioned = args.join(" ").replace("@", "") + "@s.whatsapp.net"
              bla = premium.includes(mentioned)
              if (!bla) return reply("*Este n√∫mero n√£o est√° incluso na lista premium..*")
              pesquisar = mentioned
              processo = premium.indexOf(pesquisar)
              while (processo >= 0) {
                premium.splice(processo, 1)
                processo = premium.indexOf(pesquisar)
              }
              fs.writeFileSync('./functions/premium.json', JSON.stringify(premium))
              client.sendMessage(from, { text: ` @${mentioned.split("@")[0]} foi tirado da lista premium com sucesso..` }, { quoted: info })
            }
            break

          case 'gerarcpf':
            //const isPremium = premium.includes(sender)
            if (!isPremium) return reply(resposta.premium)
            cp1 = `${Math.floor(Math.random() * 300) + 600}`
            cp2 = `${Math.floor(Math.random() * 300) + 600}`
            cp3 = `${Math.floor(Math.random() * 300) + 600}`
            cp4 = `${Math.floor(Math.random() * 30) + 60}`
            cpf = `${cp1}.${cp2}.${cp3}-${cp4}`
            await client.sendMessage(from, { text: `CPF GERADO COM SUCESSO  ${cpf}` }, { quoted: info })
            break

          case 'listafake':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            teks = 'ùóôùóîùóûùóòùó¶ ùó°ùó¢ ùóöùó•ùó®ùó£ùó¢  \n'
            men = []
            for (let mem of groupMembers) {
              if (!mem.id.startsWith(55)) {
                teks += `‚û§ @${mem.id.split('@')[0]}\n`
                men.push(mem.id)
              }
            }
            if (teks.indexOf('‚û§') < 0) return reply(' ùó°ùó≤ùóªùóµùòÇùó∫ ùóôùóÆùóπùòÄùóº ùóóùó≤ùòÅùó≤ùó∞ùòÅùóÆùó±ùóº')
            client.sendMessage(from, { text: teks, mentions: men })
            break

          case 'listabr':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            teks = 'ùóïùó•ùóîùó¶ùóúùóüùóòùóúùó•ùó¢ùó¶ ùó°ùó¢ ùóöùó•ùó®ùó£ùó¢ \n'
            men = []
            for (let mem of groupMembers) {
              if (mem.id.startsWith(55)) {
                teks += `‚û§ @${mem.id.split('@')[0]}\n`
                men.push(mem.id)
              }
            }
            if (teks.indexOf('‚û§') < 0) return reply('*NENHUM N√öMERO BR FOI ENCONTRADO*')
            client.sendMessage(from, { text: teks, mentions: men })
            break

          case 'ddd':
            if (!isPremium) return reply(resposta.premium)
            if (args.length < 1) return reply(`Use ${prefix + command} 21`)
            ddd = body.slice(5)
            ddds = await axios.get(`https://brasilapi.com.br/api/ddd/v1/${ddd}`)
            dddlist = `LISTA DE CIDADES ${ddds.data.state} COM ESTE DDD ${q}~\n\n`
            for (let i = 0; i < ddds.data.cities.length; i++) { dddlist += `${i + 1} ‚™ß *${ddds.data.cities[i]}*\n` }
            client.sendMessage(from, { text: dddlist }, { quoted: info })
            break

          case 'encurtalink':
            if (!isPremium) return reply(resposta.premium)
            if (args.length < 1) return reply(`Exemplo:\n${prefix}encurtalink https://www.youtube.com/channel/UCgKrNnrbNPJIOjJOgIXe1vQ`)
            try {
              link = args[0]
              anu = await axios.get(`https://tinyurl.com/api-create.php?url=${link}`)
              reply(`${anu.data}`)
            } catch (e) {
              emror = String(e)
              reply(`${e}`)
            }
            await limitAdd(sender)
            break

          case 'serpremium':
          case 'serprem':
            if (!isOwner) return reply(resposta.dono)
            const fss = require('fs');
            premium.push(`${infoBot.numeroDono}@s.whatsapp.net`)
            fss.writeFileSync('./functions/premium.json', JSON.stringify(premium))
            reply(`Pronto ${infoBot.numeroDono} voc√™ foi adicionado na minha lista de premium.`)
            break

          case 'google': {
            if (!q) return reply(`Examplo : ${prefix}Google bot de WhatsApp`)
            reply("aguarde um momento ")
            let google = require('google-it')
            google({ 'query': q }).then(res => {
              let teks = `Google Pesquisa \n\n`
              for (let g of res) {
                teks += `‚≠î *Titulo* : ${g.title}\n`
                teks += `‚≠î *Descri√ß√£o* : ${g.snippet}\n`
                teks += `‚≠î *Link* : ${g.link}\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`
              }
              reply(teks)
            })
          }
            break

          case 'correio':
            {
              txt = args.join(" ")
              if (!txt) return reply(`Exemplo: ${prefix + command} +55 00.../Oi amor, sdds`)
              let txt1 = txt.split("/")[0].replace(/\D/g, '');
              let txt2 = txt.split("/")[1];
              if (!txt1) return reply('Cade o n√∫mero da pessoa?')
              if (!txt2) return reply('Cade a mensagem do correio??')
              let [result] = await client.onWhatsApp(txt1)
              if (!result) return reply(`N√∫mero inv√°lido`)
              bla =
                `‚ï≠‚îÑ‚îÅ‚îÑ‚îÅ‚îÑ‚îÅ‚îÑ‚îÅ‚îÑ‚îÅ‚ïÆ
    ‚îû‚îß¬†‚∏ô. Õé€´€™¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†üíå¬†¬†ÀêÕ°‚ÇäÍûãÍûåÍûãÍûå
    ‚îû‚îßCorreio an√¥nimo. 
    ‚îû‚îßMsg: ${txt2}
    ‚îû‚îß
    ‚ï∞‚îÑ‚îÅ‚îÑ‚îÅ‚îÑ‚îÅ‚îÑ‚îÅ‚îÑ‚îÅ‚ïÆ`
              client.sendMessage(result.jid, { text: bla })
              reply(`Mensagem enviada com sucesso para wa.me/${result.jid.split("@")[0]}`)
            }
            break

          case 'metadinha':
          case 'metadinha2':
          case 'metadinha3':
            if (!isGroup) return reply(resposta.grupo)
            anuu = await fetchJson('https://raw.githubusercontent.com/iamriz7/kopel_/main/kopel.json')

            random = anuu[Math.floor(Math.random() * anuu.length)]
            let buttonssMessssage = {
              image: { url: random.male },
              caption: `ü•∂MASCULINOü•∂`,
              footer: `${nomeBot}`,
              headerType: 4
            }
            await client.sendMessage(from, buttonssMessssage, { quoted: info }).catch(err => {
              return ('Error!')
            })
            let buttonssMesssage = {
              image: { url: random.female },
              caption: `üçâFEMININOüçâ`,
              footer: `${nomeBot}`,
              headerType: 4
            }
            await client.sendMessage(from, buttonssMesssage, { quoted: info }).catch(err => {
              return ('Error!')
            })
            break



          case 'speed':
          case 'ping':
            r = (Date.now() / 1000) - info.messageTimestamp;
            uptime = process.uptime();
            hora1 = moment.tz('America/Sao_Paulo').format('HH:mm:ss');
            const data = moment.tz('America/Sao_Paulo').format('DD/MM/YY');
            let girastamp = speed();
            let latensi = speed() - girastamp;
            reply(` 
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê ¬∞‚ùÄ‚Ä¢¬∞üíñ¬∞‚Ä¢‚ùÄ¬∞‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ï†üçâ‚ûΩùôãùôÑùôâùôÇ: ${String(r.toFixed(3))}
    ‚îÉ‚ú∞ 
    ‚ï†üçâ‚ûΩùóõùó¢ùó•ùóî: ${hora1}
    ‚îÉ‚ú∞  
    ‚ï†üçâ‚ûΩùóóùóîùóßùóî: ${data}
    ‚îÉ‚ú∞ 
    ‚ï†üçâ‚ûΩùó©ùóòùóüùó¢ùóñùóúùóóùóîùóóùóò:${latensi.toFixed(4)}
    ‚îÉ‚ú∞ 
    ‚ï†üçâ‚ûΩùóßùóòùó†ùó£ùó¢ ùó¢ùó°ùóüùóúùó°ùóò: ${runtime(uptime)}
    ‚îÉ‚ú∞ 
    ‚ï†üçâ‚ûΩùóïùó¢ùóß: ${nomeBot}
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê ¬∞‚ùÄ‚Ä¢¬∞üíú¬∞‚Ä¢‚ùÄ¬∞‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`)
            break

          case 'convite':
            if (!q) return reply("cad√™ o link do grupo?")
            cnvt = args.join(" ")
            reply(`ü•≥convite enviado com sucesso para meu donoü•≥`)
            sendBtext(`${numeroDono}@s.whatsapp.net`, `üçâconvite para entra em um grupoüçâ\n\nLink do grupo: ${cnvt}\n\nN√∫mero dele(a) : wa.me/${sender.split("@")[0]}`, `${nomeBot}Ô∏è`, [
              { buttonId: `${prefix}entrar ${cnvt}`, buttonText: { displayText: `üîÆACEITAüîÆ` }, type: 1 },
              { buttonId: `${prefix}recusar ${sender}`, buttonText: { displayText: `üîÆRECUSARüîÆ` }, type: 1 }], live)
            break

          case 'recusar':
            if (!isOwner) return reply("S√≥ dono...")
            client.sendMessage(q, { text: `Ol√°,seu convite foi recusado üò™` })
            break

          case 'join': case 'entrar':
            if (!isOwner) return reply('Somente propriet√°rio!')
            string = args.join(' ')
            if (!string) return reply('Insira um link de convite ao lado do comando.')
            if (string.includes('chat.whatsapp.com/') || reply('Ops, verifique o link que voc√™ inseriu.')) {
              link = string.split('app.com/')[1]
              try {
                await client.groupAcceptInvite(`${link}`)
              } catch (erro) {
                if (String(erro).includes('resource-limit')) {
                  reply('O grupo j√° est√° com o alcance de 257 membros.')
                }
                if (String(erro).includes('not-authorized')) {
                  reply('N√£o foi poss√≠vel entrar no grupo.\nMotivo: Banimento.')
                }
              }
            }
            break

          case "tiktokvd": {
            if (q < 1) return reply("kd o link do video?")
            reply("aguarde...")
            const fitat = await fetchJson(`https://fine-gold-squid-yoke.cyclic.app/anikit/tiktok?username=Teste&key=teste&videoUrl=${q}`)
            const lip = fitat.link
            client.sendMessage(from, { video: { url: `${lip}` } }, { quoted: info });
          } break

          case 'premiumlist':
            if (!isPremium) return reply(resposta.premium)
            tkks = '‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ*„Äå *PREMIUM USERüëë* „Äç\n'
            for (let V of premium) {
              tkks += `‚îÇ+  @${V.split('@')[0]}\n`
            }
            tkks += `‚îÇ+ Total : ${premium.length}\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*„Äå *${nomeBot}* „Äç*‚îÄ‚îÄ‚îÄ‚îÄ`
            reply(tkks.trim())
            break

          case 'casal':
            if (!isGroup) return reply('S√≥ pode ser utilizado este comando, em grupo.')
            membr = []
            const suamae11 = groupMembers
            const suamae21 = groupMembers
            const teupai11 = suamae11[Math.floor(Math.random() * suamae11.length)]
            const teupai21 = suamae21[Math.floor(Math.random() * suamae21.length)]
            var shipted1 = ["1%", `2%`, `3%`, `4%`, `5%`, `6%`, `7`, `%`, `9%`, `10`, `11%`, `12%`, `13%`, `14%`, `15%`, `16%`, `17%`, `1%`, `19%`, `20%`, `21%`, `22`, `23%`, `24%`, `25%`, `26%`, `27%`, `2%`, `27%`, `2%`, `29%`, `30%`, `31%`, `32%`, `33%`, `34%`, `35%`, `36%`, `37%`, `3%`, `39%`, `40%`, `41%`, `42%`, `43%`, `44%`, `45%`, `46%`, `47%`, `4%`, `49%`, `50%`, `51%`, `52%`, `53%`, `54%`, `55%`, `56%`, `57%`, `5%`, `59%`, `60%`, `61%`, `62%`, `63%`, `64%`, `65%`, `66%`, `67%`, `6%`, `69%`, `70%`, `71%`, `72%`, `73%`, `74%`, `75%`, `76%`, `77%`, `7%`, `79%`, `0%`, `1%`, `2%`, `5%`, `4%`, `5%`, `6%`, `7%`, `%`, `9%`, `90%`, `91%`, `92%`, `93%`, `94%`, `95%`, `96%`, `97%`, `9%`, `99%`, `100%`]
            const shipted = shipted1[Math.floor(Math.random() * shipted1.length)]
            jet = `*Hmmm.... Eu Shipo eles 2üíòüíò*\n\n1= @${teupai11.id.split('@')[0]}\ne esse\n2= @${teupai21.id.split('@')[0]}\ncom uma porcentagem de: ${shipted}`
            membr.push(teupai11.id)
            membr.push(teupai21.id)
            mentions(jet, membr, true)
            break

          case 'leveling':
            if (!isGroupAdmins) return reply('comando apenas para admins')
            if (!isBotGroupAdmins) return reply(resposta.botadm)
            if (args.length < 1) return reply('digite 1 para ativar ou 0 para desativar ')
            if (Number(args[0]) === 1) {
              if (isLevelingOn) return reply('o level est√° ativo')
              levelingOn.push(from)
              fs.writeFileSync('./functions/lib/leveling.json', JSON.stringify(levelingOn))
              reply('O level foi ativo no grupo ‚úîÔ∏è')
            } else if (Number(args[0]) === 0) {
              levelingOn.splice(from, 1)
              fs.writeFileSync('./functions/lib/leveling.json', JSON.stringify(levelingOn))
              reply('O level foi desativado com sucesso neste grupo‚úîÔ∏è')
            } else {
              reply('1 para ativar, 0 para desativar ')
            }
            break

          case 'anagrama':
            if (!isGroup) return reply('comando apenas para grupos')
            const anaaleatorio = Math.floor(Math.random() * palavrasANA.length)
            if (!isGroupAdmins) return reply('comando apenas para admins')
            if (args.length == 0) return reply('use 1 para ativar o jogo do anagrama\npara desativar use anagrama 0')
            if (args.join(' ') === '1') {
              if (fs.existsSync(`./functions/anagrama-${from}.json`)) {
                let dataAnagrama2 = JSON.parse(fs.readFileSync(`./functions/anagrama-${from}.json`))
                reply(`o jogo j√° foi iniciado neste grupo:
  palavra: ${dataAnagrama2.embaralhada}
  dica: ${dataAnagrama2.dica}
  `)
              } else {
                fs.writeFileSync(`./functions/anagrama-${from}.json`, `${JSON.stringify(palavrasANA[anaaleatorio])}`)

                let atr = {
                  image: { url: logo },
                  caption: `
  ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚âΩ„Äå üëæ ANAGRAMA üëæ „Äç
  ‚îÇüçâ‚ûΩ DESCUBRA A PALAVRA
  ‚îÇüçâ‚ûΩ ANAGRAMA: ${palavrasANA[anaaleatorio].embaralhada}
  ‚îÇüçâ‚ûΩ DICA: ${palavrasANA[anaaleatorio].dica}
  ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  `,
                  lfooter: `${nomeBot}`,
                  //buttons: buttons,
                  headerType: 4
                }


                client.sendMessage(from, atr)
              }
            } else if (args.join(' ') === '0') {
              if (!fs.existsSync(`./functions/anagrama-${from}.json`)) return reply('n√£o tem como desativar o jogo do anagrama p√¥s ele n√£o foi ativado')
              fs.unlinkSync(`./functions/anagrama-${from}.json`)
              reply("desativado com sucesso")
            }
            //await limitAdd(sender)
            break

          case "level":
            if (!isLevelingOn) return reply("o leveling nao ta ativo, peca pra algum adm ativar!!!")
            reply(`
  Ola ${pushname} aqui esta suas informa√ß√µes
  
  Patente: ${role}
  Level: ${getLevel}
  porcentagem: ${per}
  `)
            break

          case 'ttp':
            if (!q) return reply(`Exemplo: ${prefix + command} Sad`)
            client.sendMessage(from, { sticker: { url: `https://api.brizaloka-api.tk/ttp/ttp3?apikey=brizaloka&text=${q}` } }, { quoted: info }).catch(e => {
              reply("ERROR...")
            })
            break

          case 'attp':
            if (args.length == 0) return reply(`Exemplo: ${prefix + command} Sad`)
            client.sendMessage(from, { sticker: { url: `https://amandaapis.onrender.com/api/attp?texto=${q}&apikey=SuaApikey` } }, { quoted: info }).catch(e => {
              reply("ERROR...")
            })
            break

          case 'attp6':
            if (args.length == 0) return reply(`Exemplo: ${prefix + command} Sad`)
            client.sendMessage(from, { sticker: { url: `https://amandaapis.onrender.com/api/attp?texto=${q}&apikey=SuaApikey` } }, { quoted: info }).catch(e => {
              reply("ERROR...")
            })
            break

          case 'attp5':
            if (args.length == 0) return reply(`Exemplo: ${prefix + command} Sad`)
            client.sendMessage(from, { sticker: { url: `https://amandaapis.onrender.com/api/attp?texto=${q}&apikey=SuaApikey` } }, { quoted: info }).catch(e => {
              reply("ERROR...")
            })
            break

          case 'attp4':
            if (args.length == 0) return reply(`Exemplo: ${prefix + command} Sad`)
            client.sendMessage(from, { sticker: { url: `https://amandaapis.onrender.com/api/attp?texto=${q}&apikey=SuaApikey` } }, { quoted: info }).catch(e => {
              reply("ERROR...")
            })
            break

          case 'attp3':
            if (args.length == 0) return reply(`Exemplo: ${prefix + command} Sad`)
            client.sendMessage(from, { sticker: { url: `https://amandaapis.onrender.com/api/attp?texto=${q}&apikey=SuaApikey` } }, { quoted: info }).catch(e => {
              reply("ERROR...")
            })
            break
          case 'attp2':
            if (args.length == 0) return reply(`Exemplo: ${prefix + command} Sad`)
            client.sendMessage(from, { sticker: { url: `https://amandaapis.onrender.com/api/attp?texto=${q}&apikey=SuaApikey` } }, { quoted: info }).catch(e => {
              reply("ERROR...")
            })
            break

          case "perfil":
            try {
              ppimg = await client.profilePictureUrl(`${sender.split("@")[0]}@c.us`, "image")
            } catch (e) {
              ppimg = logo
            }
            var conselho = palavras[Math.floor(Math.random() * palavras.length)]
            const nivelgado = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
            const nivelgado2 = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
            const nivelgador = nivelgado[Math.floor(Math.random() * (nivelgado.length))]
            const nivelgado2r = nivelgado2[Math.floor(Math.random() * (nivelgado2.length))]
            const gostosura = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
            const gostosura2 = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
            const gostosurar = gostosura[Math.floor(Math.random() * (gostosura.length))]
            const gostosurar2 = gostosura2[Math.floor(Math.random() * (gostosura2.length))]
            const programa = Math.ceil(Math.random() * 10000)
            perfil = await getBuffer(ppimg)
            reply("enviando..")
            try {
              client.sendMessage(from, {
                image: perfil,
                caption: `          „Äå üî• ~_*PERFIL*_~ üåà „Äç
  
  üìÑ *Nome* : ${pushname}
  üêÇ *N√∫mero* : ${sender.split("@")[0]}
  üîÆ *Wa.me* : https://wa.me/${sender.split("@")[0]}
  üåÇ *Grupo*: ${groupName}
  üêÇ *N√≠vel gado* : *${nivelgador}${nivelgado2r}%*
  üì± *Seu C√©lular* : ${info.key.id.length > 21 ? 'Android ü§£' : info.key.id.substring(0, 2) == '3A' ? 'IOSüòÇüòÇüòÖ' : 'Zap zap web üòÇüòÇ‚òùüèºüòÖ'}
  üòã *N√≠vel de gostosura* : *${gostosurar}${gostosurar2}%*
  üçº *Valor do programa* : *R$${programa}*
  
  ‚ûª *~_CONSELHO_~* :
  ${conselho}`
              }, { quoted: live })
            } catch (e) {
              console.log("erro")
              reply(resposta.erro)
            }
            break

          case 'report':
          case 'bug':
            if (!q) return enviar('Ex: bug no menu adm..')
            reply(`Obrigada pela colabora√ß√£o, o bug foi reportado aos meus criadores...
  üí¶üç∑bugs falsos nao ser√£o respondidos`)
            let templateMesssage = {
              image: {
                url: imagemdomenu,
                quoted: live
              },
              caption: `üí¶Ô∏èùó®ùó∫ ùóïùòÇùó¥Ô∏èüí¶\nDo N√∫mero: @${sender.split('@')[0]},\nReportou:\n${q}`,
              footer: 'Noelle_md'
            }
            client.sendMessage(`${numeroDono}@s.whatsapp.net`, templateMesssage)
            break
          case 'novocmd':
            if (!q) return enviar('Ex: novocmd coloca antilink')
            reply(`Obrigada pela colabora√ß√£o, a sua idea foi reportada aos meus criadores üòä`)
            const qp = args.join(" ")
            let templateMessage = {
              image: {
                url: imagemdomenu,
                quoted: live
              },
              caption: `üí¶IDEIA DE CMD‚ô®üí¶\nDo N√∫mero: @${sender.split('@')[0]},\nA Ideia √â:\n ${q}`,
              footer: 'Noelle_md'
            }
            client.sendMessage(`${numeroDono}@s.whatsapp.net`, templateMessage)
            break

          case 'ban':
          case 'kick':
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply(resposta.adm)
            if (!isBotGroupAdmins) return reply(resposta.botadm)

            const frases = JSON.parse(fs.readFileSync('./functions/frases.json'))
            const clover = frases[Math.floor(Math.random() * frases.length)]

            if (info.message.extendedTextMessage === undefined || info.message.extendedTextMessage === null) return reply('ùô¢ùôñùôßùô¶ùô™ùôö ùôñ ùô¢ùôöùô£ùô®ùôñùôúùôöùô¢ ùô§ùô™ ùôñ ùô•ùôöùô®ùô®ùô§ùôñ ùô¶ùô™ùôö ùô´ùôò ùôôùôöùô®ùôöùôüùôñ ùôßùôöùô¢ùô§ùô´ùôöùôß ùôôùô§ ùôúùôßùô™ùô•ùô§')
            if (info.message.extendedTextMessage.contextInfo.participant !== null && info.message.extendedTextMessage.contextInfo.participant != undefined && info.message.extendedTextMessage.contextInfo.participant !== "") {
              mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid[0] ? info.message.extendedTextMessage.contextInfo.mentionedJid[0] : info.message.extendedTextMessage.contextInfo.participant
              if (sender.includes(mentioned)) return reply("üòë")
              if (botNumber.includes(mentioned)) return reply('N√£o sou besta de remover eu mesmo n√©, mas estou decepcionado com voc√™')
              let responseb = await client.groupParticipantsUpdate(from, [mentioned], 'remove')
              if (responseb[0].status === "200") client.sendMessage(from, { text: `@${mentioned.split("@")[0]} ${clover}`, mentions: [mentioned, sender], contextInfo: { forwardingScore: 999, isForwarded: true } })
              else if (responseb[0].status === "406") client.sendMessage(from, { text: `@${mentioned.split("@")[0]} criou esse grupo e n√£o pode ser removido(a) do grupoÔ∏è`, mentions: [mentioned, sender], contextInfo: { forwardingScore: 999, isForwarded: true } })
              else if (responseb[0].status === "404") client.sendMessage(from, { text: `@${mentioned.split("@")[0]} j√° foi removido(a) ou saiu do grupo`, mentions: [mentioned, sender], contextInfo: { forwardingScore: 999, isForwarded: true } })
              else client.ontextInfoe(from, { text: `Hmm parece que deu erroÔ∏è`, mentions: [sender], contextInfo: { forwardingScore: 999, isForwarded: true } })
            } else if (info.message.extendedTextMessage.contextInfo.mentionedJid != null && info.message.extendedTextMessage.contextInfo.mentionedJid != undefined) {
              mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid
              if (mentioned.includes(sender)) return reply("üòë")
              if (mentioned.length > 1) {
                if (mentioned.length > groupMembers.length || mentioned.length === groupMembers.length || mentioned.length > groupMembers.length - 3) return reply(`Vai banir todo mundo mesmo?`)
                sexocomrato = 0
                for (let banned of mentioned) {
                  await sleep(100)
                  let responseb2 = await client.groupParticipantsUpdate(from, [banned], 'remove')
                  if (responseb2[0].status === "200") sexocomrato = sexocomrato + 1
                }
                client.sendMessage(from, { text: `${sexocomrato} participantes removido do grupo`, mentions: [sender], contextInfo: { forwardingScore: 999, isForwarded: true } })
              } else {
                let responseb3 = await client.groupParticipantsUpdate(from, [mentioned[0]], 'remove')
                if (responseb3[0].status === "200") client.sendMessage(from, { text: `@${mentioned[0].split("@")[0]} ${clover}`, mentions: [mentioned[0], sender], contextInfo: { forwardingScore: 999, isForwarded: true } })
                else if (responseb3[0].status === "406") client.sendMessage(from, { text: `@${mentioned[0].split("@")[0]} criou esse grupo e n√£o pode ser removido(a) do grupoÔ∏è`, mentions: [mentioned[0], sender], contextInfo: { forwardingScore: 999, isForwarded: true } })
                else if (responseb3[0].status === "404") client.sendMessage(from, { text: `@${mentioned[0].split("@")[0]} j√° foi removido(a) ou saiu do grupo`, mentions: [mentioned[0], sender], contextInfo: { forwardingScore: 999, isForwarded: true } })
                else client.sendMessage(from, { text: `Hmm parece que deu erroÔ∏è`, mentions: [sender], contextInfo: { forwardingScore: 999, isForwarded: true } })
              }
            }
            break

          case 'ia':
            try {
              let openai = await ia(q)
              let response = openai[0].resposta
              delay(1000)
              enviar(response)
            } catch (e) {
              console.log(e)
              reply('Erro')
            }
            break

          case "play4": {
            client.sendMessage(from, { react: { text: 'üçâ', key: info.key } })
            if (!q) return reply("digite o nome da m√∫sica que voc√™ deseja exemplo: /play teto m4")
            ab = args.join(" ")
            res = await ytttts(ab)
            reply("aguarde enviando..")
            blaimg = await getBuffer(res.all[0].image)

            bla = `
  ùëªùë∞ùëªùëºùë≥ùë∂: ${res.all[0].title}
  ùëΩùë∞ùë∫ùëºùë®ùë≥ùë∞ùíÅùë®ùë™Ãßùë∂ÃÉùë¨ùë∫: ${res.all[0].views}\n
  ùëªùë¨ùë¥ùë∑ùë∂: ${res.all[0].timestamp}
  ùë™ùë®ùëµùë®ùë≥: ${res.all[0].author.name}
  ùòöùò¶ ùò∑ùò∞ùò§ùò¶ÃÇ ùòØùò¢ÃÉùò∞ ùò§ùò∞ùòØùò¥ùò¶ùò®ùò∂ùò™ùò≥ ùò∑ùò™ùò¥ùò∂ùò¢ùò≠ùò™ùòªùò¢ùò≥ ùò∞ùò¥ ùò£ùò∞ùòµùò∞ÃÉùò¶ùò¥,ùò¶ùòπùò¶ùò§ùò∂ùòµùò¶ ùò∞ ùò±ùò≠ùò¢ùò∫ùò¢ùò∂ùò•ùò™ùò∞, ùò±ùò≠ùò¢ùò∫ùò∑ùò™ùò•ùò¶ùò∞ ùò§ùò∞ùòÆùò∞ ùò¥ùò¶ùò®ùò∂ùòØùò•ùò¢ ùò∞ùò±ùò§Ãßùò¢ÃÉùò∞.`

            sendBimg(from, `${res.all[0].image}`, bla, nomeBot, [
              { buttonId: `${prefix}playmp3 ${res.all[0].url}`, buttonText: { displayText: '„ÄéùêÄùêîùêÉùêàùêé„Äè' }, type: 1 }, { buttonId: `${prefix}playmp4 ${res.all[0].url}`, buttonText: { displayText: '„ÄéùêïùêàÃÅùêÉùêÑùêé„Äè' }, type: 1 }], live)
          }
            break

          case 'audio': case 'ytaudio':
            enviar('*enviando ‚ú®*')
            bla = await fetchJson(`https://api.brizaloka-api.tk/sociais/v2/ytplaymp3?apikey=brizaloka&query=${q}`)
            audbla = bla.link_src
            client.sendMessage(from, { audio: { url: audbla }, mimetype: 'audio/mp4' }, { quoted: live })
            break

          case 'tiktok':
            if (!q.includes("tiktok")) return reply(`Ops, insira o link, s√≥ baixo v√≠deos / audios do ${command} com link`)
            sendBtext(from, "ùêÉùê®ùê∞ùêßùê•ùê®ùêöùêù ùêÉùêû ùêïùê¢ÃÅùêùùêûùê® / ùêÄùêÆùêùùê¢ùê® [ ùêìùêàùêäùêìùêéùêä ]\nùêÑùê¨ùêúùê®ùê•ùê°ùêö ùêÆùê¶ùêö ùêùùêöùê¨ ùê®ùê©ùêúÃßùê®ÃÉùêûùê¨ ùê™ùêÆùêû ùêùùêûùê¨ùêûùê£ùêö", `‚ú®`, [
              { buttonId: `${prefix}tiktokaud ${q}`, buttonText: { displayText: `ùêÄùêîùêÉùêàùêé` }, type: 100 },
              { buttonId: `${prefix}tiktokvd ${q}`, buttonText: { displayText: `ùêïùêàùêÉùêÑùêé` }, type: 100 }
            ], live)
            break;

          case 'tiktokaud':
            reply("ERRO")
            break


          case "ppt":
            if (!isGroup) return reply(`Comando so para grupos.`)
            if (args.length < 1) return reply('exemplo: /ppt pedra')
            ppt = ["pedra", "papel", "tesoura"]
            ppy = ppt[Math.floor(Math.random() * ppt.length)]
            ppg = Math.floor(Math.random() * 50)
            pptb = ppy
            pph = `Voc√™ ganhou ${ppg} em money`
            if ((pptb == "pedra" && args == "papel") ||
              (pptb == "papel" && args == "tesoura") ||
              (pptb == "tesoura" && args == "pedra")) {
              var vit = "vitoria"
            } else if ((pptb == "pedra" && args == "tesoura") ||
              (pptb == "papel" && args == "pedra") ||
              (pptb == "tesoura" && args == "papel")) {
              var vit = "derrota"
            } else if ((pptb == "pedra" && args == "pedra") ||
              (pptb == "papel" && args == "papel") ||
              (pptb == "tesoura" && args == "tesoura")) {
              var vit = "empate"
            } else if (vit = "undefined") {
              return reply("deu erro...")
            }
            if (vit == "vitoria") {
              var tes = "Vit√≥ria do jogador"
            }
            if (vit == "derrota") {
              var tes = "A vit√≥ria √© do bot"
            }
            if (vit == "empate") {
              var tes = "O jogo terminou em empate"
            }
            reply(`Bot jogou: ${pptb}\nO jogador jogou: ${args}\n\n${tes}`)
            if (tes == "Vit√≥ria do jogador") {
              reply(pph)
            }
            break

          case 'gpwhatsapp':
          case 'gruposwhats':
          case 'gruposwa':
            if (!isPremium) return reply(resposta.premium)
            if (!q) return reply("Cad√™ o t√≠tulo da pesquisa?")
            axios.get(`https://marcos025.onrender.com/api/pesquisa/gpwhatsapp?nome=${q}&apikey=XANAX-VNCS$`)
              .then(e => {
                try {
                  d = e.data;
                  txt = '';
                  no = 0;
                  for (let i of d) {
                    no += 1;
                    txt += `‚úì üè∑ ùòïùò∞ùòÆùò¶‚ßΩ ${i.nome}\n√ó üàπ ùòãùò¶ùò¥ùò§ùò≥ùò™ùò§Ãßùò¢ÃÉùò∞‚ßΩ ${i.descri√ß√£o}\n√ó üîó ùòìùò™ùòØùò¨‚ßΩ ${i.link}\n\n`;
                  }
                  client.sendMessage(from, { image: { url: `${logo}` }, caption: txt })
                } catch (err) {
                  reply(`Nenhum resultado foi encontrado.`)
                }
              }).catch(err => {
                reply('Ops, eu acho que a api ou m√≥dulo caiu!')
                console.log(err);
              });
            break

          case "jokenpo":
            if (!isGroup) return reply("Comando s√≥ para grupos.");
            if (args.length < 1) return reply(`Exemplo: ${prefix}jokenpo pedra`);

            const opptions = ["pedra", "papel", "tesoura"];
            const botChoice = opptions[Math.floor(Math.random() * opptions.length)];
            const userChoice = args[0].toLowerCase();

            let resuult;
            let reward = 0;

            if (!opptions.includes(userChoice)) {
              resuult = "Op√ß√£o inv√°lida, escolha entre pedra, papel ou tesoura.";
            } else if (botChoice === userChoice) {
              resuult = "Empate!";
            } else if (
              (botChoice === "pedra" && userChoice === "tesoura") ||
              (botChoice === "papel" && userChoice === "pedra") ||
              (botChoice === "tesoura" && userChoice === "papel")
            ) {
              resuult = "Voc√™ perdeu!";
            } else {
              resuult = "Voc√™ ganhou!";
              reward = Math.floor(Math.random() * 50);
            }

            let message = `O bot escolheu: ${botChoice}\nVoc√™ escolheu: ${userChoice}\n\n${resuult}`;

            if (reward > 0) {
              message += `\n\nParab√©ns! Voc√™ ganhou ü•≥üí•üçâ`;
              // Aqui voc√™ pode adicionar sua l√≥gica para dar a recompensa ao usu√°rio.
            }

            reply(message);
            break;
          case "adivinha√ß√£o":
            if (!isGroup) return reply(`Comando s√≥ para grupos.`)
            if (args.length < 1) return reply(`Exemplo: ${prefix} adivinhacao 50`)
            const num = Math.floor(Math.random() * 100) + 1
            const guess = parseInt(args[0])
            if (isNaN(guess)) return reply('Digite um n√∫mero v√°lido.')
            if (guess < 1 || guess > 100) return reply('O n√∫mero deve estar entre 1 e 100.')
            if (guess === num) {
              const premio = Math.floor(Math.random() * 50) + 1
              reply(`Parab√©ns, voc√™ acertou! O n√∫mero era ${num}.\nVoc√™ ganhou ${premio} em dinheiro.`)
            } else {
              reply(`Que pena, voc√™ errou. O n√∫mero era ${num}. Tente novamente.`)
            }
            break




          case 'avalie':
            if (!q) return enviar(`Ex: ${prefix} avalia√ß√£o bot muito top..`)
            reply(`Avaliac√£o enviada com sucesso.`)
            let templateMeesssage = {
              image: {
                url: imagemdomenu,
                quoted: live
              },
              caption: `*üí¶Ô∏èAvalia√ß√£oüí¶*\nDo N√∫mero: @${sender.split('@')[0]},\nAvaliac√£o:\n${q}`,
              footer: 'Noelle_md'
            }
            client.sendMessage(`${numeroDono}@s.whatsapp.net`, templateMeesssage)
            break

          case 'gtts':
            if (args.length < 1) return reply(`Cade o texto?, digite algo Exemplo:\n${prefix}gtts PT Oi`)
            const gtts = require('./functions/functions/gtts')(args[0])
            if (args.length < 2) return reply('Falta colocar o c√≥digo do idioma!')
            dtt = body.slice(8)
            ranm = getRandom('.mp3')
            rano = getRandom('.ogg')
            if (dtt.length > 4000) return reply('Para reduzir spam o m√°ximo de letras permitidas s√£o 4000!')
            gtts.save(ranm, dtt, function () {
              exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, (err) => {
                fs.unlinkSync(ranm)
                buffer = fs.readFileSync(rano)
                client.sendMessage(from, { audio: buffer, ptt: true }, { quoted: live })
                fs.unlinkSync(rano)
              })
            })
            break

          case 'calcular':
            const resultzx = eval(q)
            await sleep(1000)
            reply(`${resultzx}`)
            break

          case 'ranklevel':
          case 'rl':
          case 'rank':
            _level.sort((a, b) => (a.xp < b.xp) ? 1 : -1)
            let leaderboardlvl = '    üèÜ„Ää Rank Niveis „ÄãüèÜ\n\n'
            let nom = 0
            try {
              for (let i = 0; i < 10; i++) {
                nom++
                leaderboardlvl += `
  ‚îè ‚úòüåñ ${nomeBot} üåò‚úò‚îì
  ‚îÉ‚Ä¢‚îÄ‚îÄ‚îÄ‚îÄ‚Ä¢‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Ä¢‚îÄ‚îÄ‚îÄ‚Ä¢
  ‚î£‚ù≤üèÜ‚ù≥ [${nom}] œü‚û† ${_level[i].id.replace('@s.whatsapp.net', '')}
  ‚î£‚ù≤üèÜ‚ù≥„Äåxp„Äç: œü${_level[i].xp}
  ‚î£‚ù≤üèÜ‚ù≥„ÄåLevel„Äç :œü‚û† ${_level[i].level}
  ‚îó ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ„Äå‚òÖ„Äç‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îö\n`

              }
              leaderboardlvl += `√ó‚Ä¢-‚Ä¢-‚Ä¢‚üÆ üèÜRanking LevelüèÜ‚üØ‚Ä¢-‚Ä¢-‚Ä¢√ó`
              client.sendMessage(from, { text: leaderboardlvl, sendEphemeral: true }, { quoted: live })
            } catch (err) {
              console.error(err)
              await reply(`Deve conter 10 pessoas com level, e o leveling deve est√° ativado para que aconte√ßa a evolu√ß√£o de level dos membros, ap√≥s as intera√ß√µes`)
            }
            break

          case 'clima':
          case 'tempo':
            client.sendMessage(from, { react: { text: `üì°`, key: info.key } })
            if (args.length < 1) return reply(`*Sintaxe correta para uso:* ${prefix + command} nome da cidade\n‚Ä¢ Caso tenha algum acento, retire ok?`)
            cidade = body.slice(7)
            clima = await axios.get(`https://api.openweathermap.org/data/2.5/weather?q=${q}&appid=f5c0840c2457fbb64188a6d4be05618f&units=metric&lang=pt_br`)
            if (clima.error) return reply(resposta.erro)
            jr = `üåû Temperatura agora: ${clima.data.main.temp}¬∫C
  üèôÔ∏è Cidade: ${clima.data.name}
  üî• Temperatura M√°xima: ${clima.data.main.temp_max}¬∞C
  ‚ùÑ Temperatura M√≠nima: ${clima.data.main.temp_min}¬∞C
  üå¶ Clima: ${clima.data.weather[0].description}
  üíß Umidade de ar: ${clima.data.main.humidity}% 
  üå´ Ventos: ${clima.data.wind.speed}  
  
  Solicitado por: ${pushname}`
            await client.sendMessage(from, { text: jr }, { quoted: info, contextInfo: { "mentionedJid": jr } })
            break


          case 'bangp':
            if (!isGroup) return reply(resposta.grupo)
            if (!isOwner && !isCmdy && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(resposta.Dono)
            if (isBanchat) return reply(`Este grupo ja est√° banido`)
            bancht.push(from)
            fs.writeFileSync('./functions/banchat.json', JSON.stringify(bancht))
            reply(`Grupo banido com sucesso`)
            break

          case 'unbangp':
            if (!isGroup) return reply(resposta.grupo)
            if (!isOwner) return reply(resposta.Dono)
            let cur = bancht.indexOf(from)
            bancht.splice(cur, 1)
            fs.writeFileSync('./functions/banchat.json', JSON.stringify(bancht))
            reply(`Grupo desbanido com sucesso...`)
            break

          case "limpar":
          case "clear":
            if (!isGroup) return reply(resposta.grupo)
            if (!isGroupAdmins) return reply('comando apenas para admins')
            reply(`L I M P A N D U üòéü§ô\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n ${nomeBot}`)
            break

          case 'walpaperanime':
            if (!isPremium) return reply(resposta.premium)
            {
              json = JSON.parse(fs.readFileSync('./functions/fotos/wall.json').toString())
              random = json[Math.floor(Math.random() * json.length)]
              /*
              let proximo = [
                {buttonId: `${prefix + command}`, buttonText: {displayText: 'üçâPROXIMOüçâ'}, type: 1},
                ]
                */
              templateMassage = {
                image: {
                  url: random,
                  quoted: live
                },
                caption: `${command}`,
                footer: `${nomeBot}`,
              }
              client.sendMessage(from, templateMassage)
            }
            break

          case 'deletar': case 'apagar': case 'delete': case 'del': case 'd':
            if (!isGroup) return reply(resposta.grupo)
            if (!SoDono && !isGroupAdmins && !isPremium) return reply(resposta.adm)
            client.sendMessage(from, { delete: { remoteJid: from, fromMe: true, id: info.message.extendedTextMessage.contextInfo.stanzaId, participant: sender } })
              .catch((err) => {
                console.log(err)
                reply('A mensagem n√£o foi enviado pelo bot...')
              })
            break

          case 'bc': case 'bcgroup': case 'transmitir': case 'transmiss√£o': {
            if (!isOwner) return reply(resposta.dono)
            if (!q) return reply(`Texto onde?\n\nExemplo : ${prefix + command} BOM DIA `)
            let getGroups = await client.groupFetchAllParticipating()
            let groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
            let anu = groups.map(v => v.id)
            for (let i of anu) {
              await sleep(150)
              let txt = `„Äå TRANSMISS√ÉO DO BOT „Äç\n\n ${q}`
              client.sendMessage(i, { text: txt })
            }
            reply(`Enviando com sucesso `)
          }
            break

          case 'playvideo':
            if (!q) return reply('*Quer pesquisar oq??*');
            reply('*enviando..*')
            dlk = await fetchJson(`https://api.brizaloka-api.tk/sociais/ytplaymp4?apikey=brizaloka&query=${q}`);
            Op = dlk.video
            client.sendMessage(from, { video: { url: Op } }, { quoted: live });
            break


          case 'playaudio':
            reply('*enviando..*')
            bla = await fetchJson(`https://api.brizaloka-api.tk/sociais/v2/ytplaymp3?apikey=brizaloka&query=${q}`)
            audbla = bla.link_src
            client.sendMessage(from, { audio: { url: audbla }, mimetype: 'audio/mp4' }, { quoted: live })
            break



          case "arma": {
            bancoDeDados = {
              "M1887": {
                "nome": "M1887",
                "descri√ß√£o": "Uma espingarda de cano duplo que inflige danos massivos em curta dist√¢ncia.",
                "dano": "Alto",
                "alcance": "Curto",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 2
              },
              "AK47": {
                "nome": "AK47",
                "descri√ß√£o": "Rifle de assalto de alta pot√™ncia com alta taxa de disparo e precis√£o moderada.",
                "dano": "Moderado",
                "alcance": "M√©dio",
                "taxa_de_disparo": "Alta",
                "capacidade_do_pente": 30
              },
              "AWM": {
                "nome": "AWM",
                "descri√ß√£o": "Rifle de precis√£o capaz de derrubar inimigos com um √∫nico tiro.",
                "dano": "Extremo",
                "alcance": "Longo",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 5
              },
              "Groza": {
                "nome": "Groza",
                "descri√ß√£o": "Rifle de assalto altamente poderoso com uma taxa de disparo e precis√£o excepcionais.",
                "dano": "Alto",
                "alcance": "M√©dio",
                "taxa_de_disparo": "Muito alta",
                "capacidade_do_pente": 30
              },
              "UMP45": {
                "nome": "UMP45",
                "descri√ß√£o": "Submetralhadora de alta cad√™ncia de tiro, equilibrada em termos de dano e controle de recuo.",
                "dano": "Moderado",
                "alcance": "Curto",
                "taxa_de_disparo": "Alta",
                "capacidade_do_pente": 25
              },
              "M1014": {
                "nome": "M1014",
                "descri√ß√£o": "Uma espingarda de combate pr√≥xima com uma taxa de disparo e dano impressionantes.",
                "dano": "Muito alto",
                "alcance": "Curto",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 6
              },
              "M60": {
                "nome": "M60",
                "descri√ß√£o": "Metralhadora com alto poder de fogo, ideal para suprimir inimigos e combates a m√©dia dist√¢ncia.",
                "dano": "Alto",
                "alcance": "M√©dio",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 60
              },
              "XM8": {
                "nome": "XM8",
                "descri√ß√£o": "Rifle de assalto de alta efici√™ncia, com √≥timo equil√≠brio entre dano, alcance e taxa de disparo.",
                "dano": "Moderado",
                "alcance": "M√©dio",
                "taxa_de_disparo": "Alta",
                "capacidade_do_pente": 30
              },
              "SCAR": {
                "nome": "SCAR",
                "descri√ß√£o": "Rifle de assalto confi√°vel, com boa precis√£o e controle de recuo.",
                "dano": "Moderado",
                "alcance": "M√©dio",
                "taxa_de_disparo": "M√©dia",
                "capacidade_do_pente": 30
              },
              "M4A1": {
                "nome": "M4A1",
                "descri√ß√£o": "Rifle de assalto vers√°til e equilibrado, adequado para v√°rias situa√ß√µes de combate.",
                "dano": "Moderado",
                "alcance": "M√©dio",
                "taxa_de_disparo": "M√©dia",
                "capacidade_do_pente": 30
              },
              "SVD": {
                "nome": "SVD",
                "descri√ß√£o": "Rifle de precis√£o semi-autom√°tico, com √≥timo alcance e dano significativo.",
                "dano": "Alto",
                "alcance": "Longo",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 10
              },
              "MP5": {
                "nome": "MP5",
                "descri√ß√£o": "Submetralhadora compacta e precisa, adequada para combates em espa√ßos confinados.",
                "dano": "Moderado",
                "alcance": "Curto",
                "taxa_de_disparo": "Alta",
                "capacidade_do_pente": 30
              },
              "SPAS12": {
                "nome": "SPAS12",
                "descri√ß√£o": "Uma espingarda de a√ß√£o por bombeamento, eficaz a curta dist√¢ncia com alto dano.",
                "dano": "Alto",
                "alcance": "Curto",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 6
              },
              "KAR98K": {
                "nome": "KAR98K",
                "descri√ß√£o": "Rifle de precis√£o de a√ß√£o por ferrolho, com excelente precis√£o e dano letal.",
                "dano": "Extremo",
                "alcance": "Longo",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 5
              },
              "M249": {
                "nome": "M249",
                "descri√ß√£o": "Metralhadora leve com grande capacidade de muni√ß√£o, ideal para controle de √°rea.",
                "dano": "Alto",
                "alcance": "M√©dio",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 100
              },
              "Thompson": {
                "nome": "Thompson",
                "descri√ß√£o": "Submetralhadora cl√°ssica de alta cad√™ncia de tiro e bom controle de recuo.",
                "dano": "Moderado",
                "alcance": "Curto",
                "taxa_de_disparo": "Alta",
                "capacidade_do_pente": 30
              },
              "VSS": {
                "nome": "VSS",
                "descri√ß√£o": "Rifle de assalto silencioso com escopo integrado e baixo recuo.",
                "dano": "Moderado",
                "alcance": "M√©dio",
                "taxa_de_disparo": "M√©dia",
                "capacidade_do_pente": 15
              },
              "MP40": {
                "nome": "MP40",
                "descri√ß√£o": "Submetralhadora de alta cad√™ncia de tiro e bom controle de recuo.",
                "dano": "Moderado",
                "alcance": "Curto",
                "taxa_de_disparo": "Muito alta",
                "capacidade_do_pente": 30
              },
              "AUG": {
                "nome": "AUG",
                "descri√ß√£o": "Rifle de assalto com excelente precis√£o, alcance e taxa de disparo.",
                "dano": "Moderado",
                "alcance": "M√©dio",
                "taxa_de_disparo": "Alta",
                "capacidade_do_pente": 30
              },
              "G18": {
                "nome": "G18",
                "descri√ß√£o": "Pistola autom√°tica com alta taxa de disparo, ideal para combate pr√≥ximo.",
                "dano": "Moderado",
                "alcance": "Curto",
                "taxa_de_disparo": "Muito alta",
                "capacidade_do_pente": 20
              },
              "P90": {
                "nome": "P90",
                "descri√ß√£o": "Submetralhadora de alta cad√™ncia de tiro e capacidade de muni√ß√£o elevada.",
                "dano": "Moderado",
                "alcance": "Curto",
                "taxa_de_disparo": "Muito alta",
                "capacidade_do_pente": 50
              },
              "Desert Eagle": {
                "nome": "Desert Eagle",
                "descri√ß√£o": "Pistola de alta pot√™ncia e precis√£o, com uma grande parada de energia.",
                "dano": "Alto",
                "alcance": "Curto",
                "taxa_de_disparo": "M√©dia",
                "capacidade_do_pente": 7
              },
              "Vector": {
                "nome": "Vector",
                "descri√ß√£o": "Submetralhadora compacta com alta cad√™ncia de tiro e boa precis√£o.",
                "dano": "Moderado",
                "alcance": "Curto",
                "taxa_de_disparo": "Muito alta",
                "capacidade_do_pente": 30
              },
              "M14": {
                "nome": "M14",
                "descri√ß√£o": "Rifle semiautom√°tico de alta precis√£o, ideal para combates de longa dist√¢ncia.",
                "dano": "Alto",
                "alcance": "Longo",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 10
              },
              "CG15": {
                "nome": "CG15",
                "descri√ß√£o": "Rifle de sinaliza√ß√£o que causa dano explosivo aos inimigos.",
                "dano": "Moderado",
                "alcance": "M√©dio",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 1
              },
              "USP": {
                "nome": "USP",
                "descri√ß√£o": "Pistola de m√©dio alcance com boa precis√£o e taxa de disparo.",
                "dano": "Moderado",
                "alcance": "M√©dio",
                "taxa_de_disparo": "M√©dia",
                "capacidade_do_pente": 12
              },
              "M1873": {
                "nome": "M1873",
                "descri√ß√£o": "Rev√≥lver de a√ß√£o simples com alto dano, mas taxa de disparo baixa.",
                "dano": "Alto",
                "alcance": "Curto",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 2
              },
              "AN94": {
                "nome": "AN94",
                "descri√ß√£o": "Rifle de assalto com um modo de disparo especial que aumenta a taxa de disparo.",
                "dano": "Moderado",
                "alcance": "M√©dio",
                "taxa_de_disparo": "Alta",
                "capacidade_do_pente": 30
              },
              "M79": {
                "nome": "M79",
                "descri√ß√£o": "Lan√ßador de granadas que causa danos em √°rea com alto poder de explos√£o.",
                "dano": "Extremo",
                "alcance": "Longo",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 1
              },
              "M14": {
                "nome": "M14",
                "descri√ß√£o": "Rifle semiautom√°tico de alta precis√£o, ideal para combates de longa dist√¢ncia.",
                "dano": "Alto",
                "alcance": "Longo",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 10
              },
              "CG15": {
                "nome": "CG15",
                "descri√ß√£o": "Rifle de sinaliza√ß√£o que causa dano explosivo aos inimigos.",
                "dano": "Moderado",
                "alcance": "M√©dio",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 1
              },
              "USP": {
                "nome": "USP",
                "descri√ß√£o": "Pistola de m√©dio alcance com boa precis√£o e taxa de disparo.",
                "dano": "Moderado",
                "alcance": "M√©dio",
                "taxa_de_disparo": "M√©dia",
                "capacidade_do_pente": 12
              },
              "M1873": {
                "nome": "M1873",
                "descri√ß√£o": "Rev√≥lver de a√ß√£o simples com alto dano, mas taxa de disparo baixa.",
                "dano": "Alto",
                "alcance": "Curto",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 2
              },
              "AN94": {
                "nome": "AN94",
                "descri√ß√£o": "Rifle de assalto com um modo de disparo especial que aumenta a taxa de disparo.",
                "dano": "Moderado",
                "alcance": "M√©dio",
                "taxa_de_disparo": "Alta",
                "capacidade_do_pente": 30
              },
              "M79": {
                "nome": "M79",
                "descri√ß√£o": "Lan√ßador de granadas que causa danos em √°rea com alto poder de explos√£o.",
                "dano": "Extremo",
                "alcance": "Longo",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 1
              },
              "M82B": {
                "nome": "M82B",
                "descri√ß√£o": "Rifle de precis√£o de a√ß√£o por ferrolho com alto dano e capacidade de penetra√ß√£o.",
                "dano": "Extremo",
                "alcance": "Longo",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 5
              },
              "P90": {
                "nome": "P90",
                "descri√ß√£o": "Submetralhadora de alta cad√™ncia de tiro e capacidade de muni√ß√£o elevada.",
                "dano": "Moderado",
                "alcance": "Curto",
                "taxa_de_disparo": "Muito alta",
                "capacidade_do_pente": 50
              },
              "Desert Eagle": {
                "nome": "Desert Eagle",
                "descri√ß√£o": "Pistola de alta pot√™ncia e precis√£o, com uma grande parada de energia.",
                "dano": "Alto",
                "alcance": "Curto",
                "taxa_de_disparo": "M√©dia",
                "capacidade_do_pente": 7
              },
              "M1887": {
                "nome": "M1887",
                "descri√ß√£o": "Espingarda de a√ß√£o por ferrolho com alto dano em combates de curta dist√¢ncia.",
                "dano": "Extremo",
                "alcance": "Curto",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 2
              },
              "XM8": {
                "nome": "XM8",
                "descri√ß√£o": "Rifle de assalto com boa precis√£o e cad√™ncia de tiro.",
                "dano": "Moderado",
                "alcance": "M√©dio",
                "taxa_de_disparo": "M√©dia",
                "capacidade_do_pente": 30
              },
              "KAR98K": {
                "nome": "KAR98K",
                "descri√ß√£o": "Rifle de precis√£o de a√ß√£o por ferrolho com alto dano e precis√£o.",
                "dano": "Extremo",
                "alcance": "Longo",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 5
              },
              "M79": {
                "nome": "M79",
                "descri√ß√£o": "Lan√ßador de granadas que causa danos em √°rea com alto poder de explos√£o.",
                "dano": "Extremo",
                "alcance": "Longo",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 1
              },
              "MP40": {
                "nome": "MP40",
                "descri√ß√£o": "Submetralhadora de alta cad√™ncia de tiro e bom controle de recuo.",
                "dano": "Moderado",
                "alcance": "Curto",
                "taxa_de_disparo": "Muito alta",
                "capacidade_do_pente": 30
              },
              "M14": {
                "nome": "M14",
                "descri√ß√£o": "Rifle semiautom√°tico de alta precis√£o, ideal para combates de longa dist√¢ncia.",
                "dano": "Alto",
                "alcance": "Longo",
                "taxa_de_disparo": "Baixa",
                "capacidade_do_pente": 10
              }
            }


            const armaPesquisada = args.join(" "); // Substitua pelo valor desejado
            let resultado = null;

            for (const arma in bancoDeDados) {
              if (arma.toLowerCase() === armaPesquisada.toLowerCase()) {
                resultado = bancoDeDados[arma];
                break;
              }
            }

            if (resultado) {
              reply(`*${resultado.nome}*\n*${resultado.descri√ß√£o}*\n\n*Dano: ${resultado.dano}*\n\n*Alcance: ${resultado.alcance}*\n\n*Taxa de Disparo: ${resultado.taxa_de_disparo}*\n\n*Capacidade do Pente: ${resultado.capacidade_do_pente}*`);
            } else {
              reply('Erro: Arma n√£o encontrada no banco de dados.');
            }
          } break














//====================//


          default:
            if (isCmd && command) {
              const buttonMessage = { text: `comando inexistente...` }
              client.sendMessage(from, buttonMessage)
            }

        }

      } catch (e) {
        console.log(e)
      }
    });

  }
  // Conectar √† rede do WhatsApp
  starts();

} catch (error) {
  console.error("Ocorreu um erro:", error);
}
